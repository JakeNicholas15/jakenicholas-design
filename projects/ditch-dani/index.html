<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ditch Dani</title>
<!-- v: ditch-dani-007 -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

<link rel="preload" as="image" href="/projects/ditch-dani/ditch.jpg?v=7">
<link rel="preload" as="image" href="/projects/ditch-dani/dani_idle.png?v=7">
<link rel="preload" as="image" href="/projects/ditch-dani/dani_drag_sprites.png?v=7">

<style>
  :root{
    --ditch-left: 52%;
    --ditch-top:  68%;
    --ditch-w:    56%;
    --ditch-h:    28%;
    --slope-band: 10%;
    --ground-y:   60%;

    --start-left: 72vw;
    --start-top:  48vh;

    --g: 1800;
    --slide-speed: 520;

    --frames: 4; /* we’ll divide the sheet into 4 frames in JS */
  }

  *{ box-sizing:border-box; }
  html, body{
    margin:0; height:100%; overflow:hidden; background:#000;
    font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }

  .stage{
    position:fixed; inset:0;
    background: #000 center/cover no-repeat url("/projects/ditch-dani/ditch.jpg?v=7");
    background-position: 55% 60%;
  }

  .hitbox{ position:absolute; pointer-events:none; display:none; }
  .hitbox.debug{ display:block; }
  .ditch-box{ outline:2px dashed rgba(255,255,255,.85); outline-offset:2px; }
  .slope-box{ outline:2px dashed rgba(255,200,0,.8); }

  .dani{
    position:absolute;
    left: var(--start-left);
    top:  var(--start-top);
    width: clamp(90px, 16vw, 220px);
    aspect-ratio: 600 / 700;  /* desired portrait box */
    user-select:none; -webkit-user-drag:none;
    touch-action:none;
    cursor:grab;
    transform: translateZ(0);
    will-change: left, top, transform;
  }
  .dani:active{ cursor:grabbing; }

  /* idle still */
  .idle{
    position:absolute; inset:0;
    width:100%; height:100%; object-fit:contain;
    pointer-events:none;
    transition: opacity .12s linear;
  }

  /* canvas anim layer */
  .animCanvas{
    position:absolute; inset:0;
    width:100%; height:100%;
    display:block;
    pointer-events:none;
    opacity:0;
  }

  .animating .idle{ opacity:0; }
  .animating .animCanvas{ opacity:1; }

  /* bubble */
  .bubble{
    position:absolute;
    max-width: 56vw;
    background:#fff; color:#111;
    border-radius:18px; padding:10px 14px;
    font-size: clamp(14px, 2.6vw, 20px);
    line-height:1.25;
    box-shadow: 0 8px 28px rgba(0,0,0,0.25);
    opacity:0; transform: translateY(6px);
    transition: opacity .22s ease, transform .22s ease;
    pointer-events:none;
  }
  .bubble::after{ content:""; position:absolute; left:12px; bottom:-10px;
    border:10px solid transparent; border-top-color:#fff; }
  .bubble.is-visible{ opacity:1; transform: translateY(0); }

  /* back btn */
  #backBtn{
    position: fixed; left:16px; bottom:16px;
    width:56px; height:56px; display:flex; align-items:center; justify-content:center;
    font-size:32px; border-radius:999px; color:#fff; text-decoration:none; cursor:pointer;
    background: rgba(255,255,255,0.15);
    backdrop-filter: blur(12px) saturate(1.2);
    -webkit-backdrop-filter: blur(12px) saturate(1.2);
    z-index:9999; transition: transform .15s ease, background .2s ease;
  }
  #backBtn:hover{ transform: translateY(-1px); background: rgba(255,255,255,0.22); }

  /* mobile tweaks */
  @media (max-width: 680px){
    .stage{ background-position: 60% 68%; }
    :root{
      --start-left: 68vw;
      --start-top:  46vh;
      --g: 1500;
      --slide-speed: 460;
    }
    .dani{ width: clamp(84px, 22vw, 160px); }
  }
</style>
</head>
<body>
  <div class="stage" aria-hidden="true"></div>

  <!-- debug boxes -->
  <div id="ditchBox"  class="hitbox ditch-box"></div>
  <div id="slopeLeft" class="hitbox slope-box"></div>
  <div id="slopeRight"class="hitbox slope-box"></div>

  <!-- Dani -->
  <div id="dani" class="dani">
    <img class="idle" src="/projects/ditch-dani/dani_idle.png?v=7" alt="Dani">
    <canvas id="animCanvas" class="animCanvas" aria-hidden="true"></canvas>
  </div>

  <div id="bubble" class="bubble">Dang I’m Ditched</div>

  <a id="backBtn" href="../../" aria-label="Back to gallery">←</a>

<script>
(() => {
  const dani = document.getElementById('dani');
  const bubble = document.getElementById('bubble');
  const ditchBox = document.getElementById('ditchBox');
  const slopeLeft = document.getElementById('slopeLeft');
  const slopeRight = document.getElementById('slopeRight');

  /* ---------- canvas sprite renderer ---------- */
  const canvas = document.getElementById('animCanvas');
  const ctx = canvas.getContext('2d', { alpha: true });

  const sheet = new Image();
  sheet.src = '/projects/ditch-dani/dani_drag_sprites.png?v=7';

  const FRAMES = 4;
  const FPS = 16;                // looks good for 4 frames
  const FRAME_TIME = 1000 / FPS;
  let frameIndex = 0;
  let animReq = null;
  let lastTick = 0;

  function sizeCanvas(){
    const dpr = Math.max(1, devicePixelRatio || 1);
    const r = dani.getBoundingClientRect();
    canvas.width  = Math.round(r.width * dpr);
    canvas.height = Math.round(r.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0); // scale drawings to CSS pixels
  }
  sizeCanvas();
  addEventListener('resize', sizeCanvas);

  function drawFrame(){
    if (!sheet.complete || !sheet.naturalWidth) return;
    // Divide sprite sheet into 4 equal columns (works even if there’s gutter)
    const sw = sheet.naturalWidth / FRAMES; // source frame width in px
    const sh = sheet.naturalHeight;
    const sx = Math.floor(frameIndex % FRAMES) * sw;

    // Clear then draw current frame scaled to canvas size
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.drawImage(sheet, sx, 0, sw, sh, 0, 0, canvas.width, canvas.height);
  }

  function startSprite(){
    if (animReq) return;
    lastTick = performance.now();
    const step = (now) => {
      if (now - lastTick >= FRAME_TIME){
        frameIndex = (frameIndex + 1) % FRAMES;
        drawFrame();
        lastTick = now;
      }
      animReq = requestAnimationFrame(step);
    };
    // draw first frame immediately
    drawFrame();
    animReq = requestAnimationFrame(step);
    dani.classList.add('animating');
  }
  function stopSprite(){
    if (animReq){ cancelAnimationFrame(animReq); animReq = null; }
    dani.classList.remove('animating');
  }

  /* ---------- helpers ---------- */
  const cssNum = (prop) => parseFloat(getComputedStyle(document.documentElement).getPropertyValue(prop));
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const easeOutQuad = (t)=>1-(1-t)*(1-t);

  function computeZones(){
    const vw = innerWidth, vh = innerHeight;

    const leftPct = cssNum('--ditch-left')/100;
    const topPct  = cssNum('--ditch-top')/100;
    const wPct    = cssNum('--ditch-w')/100;
    const hPct    = cssNum('--ditch-h')/100;
    const bandPct = cssNum('--slope-band')/100;

    const ditch = {
      x: vw*leftPct - (vw*wPct)/2,
      y: vh*topPct  - (vh*hPct)/2,
      w: vw*wPct,
      h: vh*hPct
    };
    const band = ditch.w * bandPct;
    const slopeL = { x: ditch.x - band, y: ditch.y, w: band, h: ditch.h };
    const slopeR = { x: ditch.x + ditch.w, y: ditch.y, w: band, h: ditch.h };

    placeBox(ditchBox, ditch);
    placeBox(slopeLeft, slopeL);
    placeBox(slopeRight, slopeR);

    const groundY = vh * (cssNum('--ground-y')/100);
    return { ditch, slopeL, slopeR, groundY };
  }
  function placeBox(el, r){
    el.style.left = r.x+'px'; el.style.top = r.y+'px';
    el.style.width = r.w+'px'; el.style.height = r.h+'px';
  }
  const rectToDOMRect = (r)=>({left:r.x, top:r.y, right:r.x+r.w, bottom:r.y+r.h});
  const intersects = (a,b)=>!(a.right<b.left||a.left>b.right||a.bottom<b.top||a.top>b.bottom);
  const centerOf = (el)=>{ const r=el.getBoundingClientRect(); return {x:r.left+r.width/2,y:r.top+r.height/2,w:r.width,h:r.height,rect:r}; };
  function placeCenter(el, cx, cy){ const w=el.offsetWidth,h=el.offsetHeight; el.style.left=Math.round(cx-w/2)+'px'; el.style.top=Math.round(cy-h/2)+'px'; }

  /* ---------- drag + physics ---------- */
  let dragging=false, activeId=null, offsetX=0, offsetY=0, downPos={x:0,y:0}, holdTimer=null;
  const isCoarse = matchMedia('(pointer:coarse)').matches;
  const HOLD_DELAY = isCoarse ? 140 : 0;
  const MOVE_TOL = 8;

  dani.addEventListener('dragstart', e=>e.preventDefault());

  dani.addEventListener('pointerdown', (e)=>{
    activeId = e.pointerId;
    dani.setPointerCapture(activeId);
    const r = dani.getBoundingClientRect();
    offsetX = e.clientX - r.left;
    offsetY = e.clientY - r.top;
    downPos = {x:e.clientX, y:e.clientY};
    bubble.classList.remove('is-visible');
    if(HOLD_DELAY){ holdTimer = setTimeout(beginDrag, HOLD_DELAY); }
    else { beginDrag(); }
  });

  addEventListener('pointermove', (e)=>{
    if(e.pointerId!==activeId) return;
    if(!dragging && holdTimer){
      const dx=Math.abs(e.clientX-downPos.x), dy=Math.abs(e.clientY-downPos.y);
      if(dx>MOVE_TOL||dy>MOVE_TOL){ clearTimeout(holdTimer); holdTimer=null; beginDrag(); }
    }
    if(!dragging) return;
    e.preventDefault();
    const x = e.clientX - offsetX;
    const y = e.clientY - offsetY;
    const maxX = innerWidth  - dani.offsetWidth;
    const maxY = innerHeight - dani.offsetHeight;
    dani.style.left = clamp(x,0,maxX)+'px';
    dani.style.top  = clamp(y,0,maxY)+'px';
    sizeCanvas(); // keep canvas in sync if CSS size changes (e.g., zoom)
  }, {passive:false});

  addEventListener('pointerup', (e)=>{
    if(e.pointerId!==activeId) return;
    if(holdTimer){ clearTimeout(holdTimer); holdTimer=null; }

    if(dragging){
      dragging=false;
      const zones = computeZones();
      const r = dani.getBoundingClientRect();
      const inDitch = intersects(r, rectToDOMRect(zones.ditch));
      const inSlopeL= intersects(r, rectToDOMRect(zones.slopeL));
      const inSlopeR= intersects(r, rectToDOMRect(zones.slopeR));

      if(inDitch){
        fallTo(zones.ditch.x + zones.ditch.w/2, zones.ditch.y + zones.ditch.h, () => {
          stopSprite(); positionBubble(); bubble.classList.add('is-visible');
        });
      }else if(inSlopeL||inSlopeR){
        slideToCenter(zones, () => { stopSprite(); positionBubble(); bubble.classList.add('is-visible'); });
      }else{
        const c=centerOf(dani);
        fallTo(c.x, zones.groundY, () => stopSprite());
      }
    }

    dani.releasePointerCapture(activeId);
    activeId=null;
  });

  function beginDrag(){
    if(dragging) return;
    dragging=true;
    sizeCanvas();
    startSprite();
  }

  /* ---------- motion ---------- */
  const cssNum = (prop) => parseFloat(getComputedStyle(document.documentElement).getPropertyValue(prop));

  function fallTo(targetX, targetY, onDone){
    const start = centerOf(dani);
    const g = cssNum('--g');

    const dx = targetX - start.x;
    const dy = targetY - start.y;

    const tFall = Math.sqrt(Math.max(2 * Math.max(dy, 1) / g, 0.0001));
    const vx = dx / tFall;
    let vy = 0;

    let last = performance.now();
    const step = (now)=>{
      const dt = (now - last)/1000; last = now;
      vy += g * dt;

      const r = dani.getBoundingClientRect();
      let cx = r.left + r.width/2 + vx * dt;
      let cy = r.top  + r.height/2 + vy * dt;

      if ((dy >= 0 && cy >= targetY) || (dy < 0 && cy <= targetY)){
        placeCenter(dani, targetX, targetY);
        onDone && onDone();
        return;
      }
      placeCenter(dani, cx, cy);
      animReqFall = requestAnimationFrame(step);
    };
    let animReqFall = requestAnimationFrame((now)=>{ last = now; requestAnimationFrame(step); });
  }

  function slideToCenter(zones, onDone){
    const start = centerOf(dani);
    const target = { x: zones.ditch.x + zones.ditch.w/2, y: zones.ditch.y + zones.ditch.h };

    const dx = target.x - start.x;
    const dy = target.y - start.y;
    const dist = Math.hypot(dx, dy);
    const speed = cssNum('--slide-speed');
    const duration = Math.max(0.2, dist / speed) * 1000;

    const t0 = performance.now();
    const step = (now)=>{
      const t = clamp((now - t0)/duration, 0, 1);
      const e = 1 - (1-t)*(1-t); // easeOutQuad
      placeCenter(dani, start.x + dx * e, start.y + dy * e);
      if (t >= 1){ onDone && onDone(); }
      else requestAnimationFrame(step);
    };
    requestAnimationFrame(step);
  }

  /* ---------- bubble ---------- */
  function positionBubble(){
    const r = dani.getBoundingClientRect();
    let bx = r.left + 12;
    let by = r.top  - 44;
    const pad = 8;
    const maxX = innerWidth  - 180;
    const maxY = innerHeight - 48;
    bx = clamp(bx, pad, maxX);
    by = clamp(by, pad, maxY);
    bubble.style.left = bx + 'px';
    bubble.style.top  = by + 'px';
  }

  /* ---------- debug ---------- */
  let debug = false;
  addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'd'){
      debug = !debug;
      const z = computeZones();
      [ditchBox, slopeLeft, slopeRight].forEach(el => el.classList.toggle('debug', debug));
    }
  });

  computeZones();
})();
</script>
</body>
</html>
