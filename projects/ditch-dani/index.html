<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
<meta http-equiv="Pragma" content="no-cache">
<meta http-equiv="Expires" content="0">
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Ditch Dani</title>
<!-- v: ditch-dani-006 -->
<link rel="preconnect" href="https://fonts.googleapis.com">
<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">

<link rel="preload" as="image" href="/projects/ditch-dani/ditch.jpg?v=6">
<link rel="preload" as="image" href="/projects/ditch-dani/dani_idle.png?v=6">
<link rel="preload" as="image" href="/projects/ditch-dani/dani_drag_sprites.png?v=6">

<style>
  :root{
    --ditch-left: 52%;
    --ditch-top:  68%;
    --ditch-w:    56%;
    --ditch-h:    28%;
    --slope-band: 10%;
    --ground-y:   60%;

    --start-left: 72vw;
    --start-top:  48vh;

    --g: 1800;
    --slide-speed: 520;

    --frames: 4; /* 600x700 each */
  }

  *{ box-sizing:border-box; }
  html, body{
    margin:0; height:100%; overflow:hidden; background:#000;
    font-family: "Inter", system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
  }

  .stage{
    position:fixed; inset:0;
    background: #000 center/cover no-repeat url("/projects/ditch-dani/ditch.jpg?v=6");
    background-position: 55% 60%;
  }

  .hitbox{ position:absolute; pointer-events:none; display:none; }
  .hitbox.debug{ display:block; }
  .ditch-box{ outline:2px dashed rgba(255,255,255,.85); outline-offset:2px; }
  .slope-box{ outline:2px dashed rgba(255,200,0,.8); }

  .dani{
    position:absolute;
    left: var(--start-left);
    top:  var(--start-top);
    width: clamp(90px, 16vw, 220px);
    aspect-ratio: 600 / 700;
    user-select:none; -webkit-user-drag:none;
    touch-action:none;
    cursor:grab;
    transform: translateZ(0);
    will-change: left, top, transform;
  }
  .dani:active{ cursor:grabbing; }

  /* Idle still */
  .idle{
    position:absolute; inset:0;
    width:100%; height:100%; object-fit:contain;
    pointer-events:none;
    transition: opacity .12s linear;
  }

  /* New robust sprite approach: crop box + sliding strip image */
  .animLayer{
    position:absolute; inset:0;
    overflow:hidden;             /* crops to one frame */
    opacity:0;                   /* hidden until animating */
    pointer-events:none;
  }
  .sheet{
    width: 400%;                 /* 4 frames horizontally */
    height: 100%;
    display:block;
    will-change: transform;
    image-rendering: -webkit-optimize-contrast;
  }

  /* While animating, hide idle and animate strip with steps(4) */
  .animating .idle{ opacity:0; }
  .animating .animLayer{ opacity:1; }
  .animating .sheet{
    animation: kick 0.25s steps(4) infinite; /* ~16 fps */
  }
  @keyframes kick{
    to { transform: translateX(-75%); } /* 0%, -25%, -50%, -75% */
  }

  /* Speech bubble */
  .bubble{
    position:absolute;
    max-width: 56vw;
    background:#fff; color:#111;
    border-radius:18px; padding:10px 14px;
    font-size: clamp(14px, 2.6vw, 20px);
    line-height:1.25;
    box-shadow: 0 8px 28px rgba(0,0,0,0.25);
    opacity:0; transform: translateY(6px);
    transition: opacity .22s ease, transform .22s ease;
    pointer-events:none;
  }
  .bubble::after{ content:""; position:absolute; left:12px; bottom:-10px;
    border:10px solid transparent; border-top-color:#fff; }
  .bubble.is-visible{ opacity:1; transform: translateY(0); }

  #backBtn{
    position: fixed; left:16px; bottom:16px;
    width:56px; height:56px; display:flex; align-items:center; justify-content:center;
    font-size:32px; border-radius:999px; color:#fff; text-decoration:none; cursor:pointer;
    background: rgba(255,255,255,0.15);
    backdrop-filter: blur(12px) saturate(1.2);
    -webkit-backdrop-filter: blur(12px) saturate(1.2);
    z-index:9999; transition: transform .15s ease, background .2s ease;
  }
  #backBtn:hover{ transform: translateY(-1px); background: rgba(255,255,255,0.22); }

  @media (max-width: 680px){
    .stage{ background-position: 60% 68%; }
    :root{
      --start-left: 68vw;
      --start-top:  46vh;
      --g: 1500;
      --slide-speed: 460;
    }
    .dani{ width: clamp(84px, 22vw, 160px); }
  }
</style>
</head>
<body>
  <div class="stage" aria-hidden="true"></div>

  <div id="ditchBox"  class="hitbox ditch-box"></div>
  <div id="slopeLeft" class="hitbox slope-box"></div>
  <div id="slopeRight"class="hitbox slope-box"></div>

  <div id="dani" class="dani">
    <img class="idle" src="/projects/ditch-dani/dani_idle.png?v=6" alt="Dani">
    <div class="animLayer" aria-hidden="true">
      <img class="sheet" src="/projects/ditch-dani/dani_drag_sprites.png?v=6" alt="">
    </div>
  </div>

  <div id="bubble" class="bubble">Dang I’m Ditched</div>

  <a id="backBtn" href="../../" aria-label="Back to gallery">←</a>

<script>
(() => {
  const dani = document.getElementById('dani');
  const bubble = document.getElementById('bubble');
  const ditchBox = document.getElementById('ditchBox');
  const slopeLeft = document.getElementById('slopeLeft');
  const slopeRight = document.getElementById('slopeRight');

  /* ---------- helpers ---------- */
  const cssNum = (prop) => parseFloat(getComputedStyle(document.documentElement).getPropertyValue(prop));
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const easeOutQuad = (t)=>1-(1-t)*(1-t);

  function computeZones(){
    const vw = innerWidth, vh = innerHeight;

    const leftPct = cssNum('--ditch-left')/100;
    const topPct  = cssNum('--ditch-top')/100;
    const wPct    = cssNum('--ditch-w')/100;
    const hPct    = cssNum('--ditch-h')/100;
    const bandPct = cssNum('--slope-band')/100;

    const ditch = {
      x: vw*leftPct - (vw*wPct)/2,
      y: vh*topPct  - (vh*hPct)/2,
      w: vw*wPct,
      h: vh*hPct
    };
    const band = ditch.w * bandPct;
    const slopeL = { x: ditch.x - band, y: ditch.y, w: band, h: ditch.h };
    const slopeR = { x: ditch.x + ditch.w, y: ditch.y, w: band, h: ditch.h };

    placeBox(ditchBox, ditch);
    placeBox(slopeLeft, slopeL);
    placeBox(slopeRight, slopeR);

    const groundY = vh * (cssNum('--ground-y')/100);
    return { ditch, slopeL, slopeR, groundY };
  }
  function placeBox(el, r){
    el.style.left = r.x+'px'; el.style.top = r.y+'px';
    el.style.width = r.w+'px'; el.style.height = r.h+'px';
  }
  const rectToDOMRect = (r)=>({left:r.x, top:r.y, right:r.x+r.w, bottom:r.y+r.h});
  const intersects = (a,b)=>!(a.right<b.left||a.left>b.right||a.bottom<b.top||a.top>b.bottom);
  const centerOf = (el)=>{ const r=el.getBoundingClientRect(); return {x:r.left+r.width/2,y:r.top+r.height/2,w:r.width,h:r.height,rect:r}; };
  function placeCenter(el, cx, cy){ const w=el.offsetWidth,h=el.offsetHeight; el.style.left=Math.round(cx-w/2)+'px'; el.style.top=Math.round(cy-h/2)+'px'; }

  /* ---------- drag ---------- */
  let dragging=false, activeId=null, offsetX=0, offsetY=0, downPos={x:0,y:0}, holdTimer=null;
  const isCoarse = matchMedia('(pointer:coarse)').matches;
  const HOLD_DELAY = isCoarse ? 140 : 0;
  const MOVE_TOL = 8;

  dani.addEventListener('dragstart', e=>e.preventDefault());

  dani.addEventListener('pointerdown', (e)=>{
    activeId = e.pointerId;
    dani.setPointerCapture(activeId);
    const r = dani.getBoundingClientRect();
    offsetX = e.clientX - r.left;
    offsetY = e.clientY - r.top;
    downPos = {x:e.clientX, y:e.clientY};
    bubble.classList.remove('is-visible'); // hide bubble on new drag
    if(HOLD_DELAY){ holdTimer = setTimeout(startDrag, HOLD_DELAY); }
    else{ startDrag(); }
  });

  addEventListener('pointermove', (e)=>{
    if(e.pointerId!==activeId) return;
    if(!dragging && holdTimer){
      const dx=Math.abs(e.clientX-downPos.x), dy=Math.abs(e.clientY-downPos.y);
      if(dx>MOVE_TOL||dy>MOVE_TOL){ clearTimeout(holdTimer); holdTimer=null; startDrag(); }
    }
    if(!dragging) return;
    e.preventDefault();
    const x = e.clientX - offsetX;
    const y = e.clientY - offsetY;
    const maxX = innerWidth  - dani.offsetWidth;
    const maxY = innerHeight - dani.offsetHeight;
    dani.style.left = clamp(x,0,maxX)+'px';
    dani.style.top  = clamp(y,0,maxY)+'px';
  }, {passive:false});

  addEventListener('pointerup', (e)=>{
    if(e.pointerId!==activeId) return;
    if(holdTimer){ clearTimeout(holdTimer); holdTimer=null; }

    if(dragging){
      dragging=false;

      const zones = computeZones();
      const r = dani.getBoundingClientRect();
      const inDitch = intersects(r, rectToDOMRect(zones.ditch));
      const inSlopeL= intersects(r, rectToDOMRect(zones.slopeL));
      const inSlopeR= intersects(r, rectToDOMRect(zones.slopeR));

      if(inDitch){
        fallTo(zones.ditch.x + zones.ditch.w/2, zones.ditch.y + zones.ditch.h, () => {
          positionBubble(); bubble.classList.add('is-visible');
        });
      }else if(inSlopeL||inSlopeR){
        slideToCenter(zones, () => { positionBubble(); bubble.classList.add('is-visible'); });
      }else{
        const c=centerOf(dani);
        fallTo(c.x, zones.groundY, () => setAnimating(false));
      }
    }

    dani.releasePointerCapture(activeId);
    activeId=null;
  });

  function startDrag(){
    if(dragging) return;
    dragging=true;
    setAnimating(true);
  }

  function setAnimating(on){
    dani.classList.toggle('animating', !!on);
    if(!on){
      // force animation style reset for Safari
      const sheet = dani.querySelector('.sheet');
      sheet.style.animation = 'none';
      // next frame to allow it to be restarted later
      requestAnimationFrame(()=>{ sheet.style.animation=''; });
    }
  }

  /* ---------- motion ---------- */
  function fallTo(targetX, targetY, onDone){
    const start = centerOf(dani);
    const g = cssNum('--g');

    setAnimating(true);

    const dx = targetX - start.x;
    const dy = targetY - start.y;

    const tFall = Math.sqrt(Math.max(2 * Math.max(dy, 1) / g, 0.0001));
    const vx = dx / tFall;
    let vy = 0;

    let last = performance.now();
    function step(now){
      const dt = (now - last)/1000; last = now;
      vy += g * dt;

      const r = dani.getBoundingClientRect();
      let cx = r.left + r.width/2 + vx * dt;
      let cy = r.top  + r.height/2 + vy * dt;

      if ( (dy >= 0 && cy >= targetY) || (dy < 0 && cy <= targetY) ){
        placeCenter(dani, targetX, targetY);
        setAnimating(false);
        onDone && onDone();
        return;
      }
      placeCenter(dani, cx, cy);
      requestAnimationFrame(step);
    }
    requestAnimationFrame((now)=>{ last = now; requestAnimationFrame(step); });
  }

  function slideToCenter(zones, onDone){
    const start = centerOf(dani);
    const target = { x: zones.ditch.x + zones.ditch.w/2, y: zones.ditch.y + zones.ditch.h };

    setAnimating(true);

    const dx = target.x - start.x;
    const dy = target.y - start.y;
    const dist = Math.hypot(dx, dy);
    const speed = cssNum('--slide-speed');
    const duration = Math.max(0.2, dist / speed) * 1000;

    const t0 = performance.now();
    function step(now){
      const t = clamp((now - t0)/duration, 0, 1);
      const e = easeOutQuad(t);
      const cx = start.x + dx * e;
      const cy = start.y + dy * e;

      placeCenter(dani, cx, cy);

      if (t >= 1){
        setAnimating(false);
        onDone && onDone();
        return;
      }
      requestAnimationFrame(step);
    }
    requestAnimationFrame(step);
  }

  /* ---------- bubble ---------- */
  function positionBubble(){
    const r = dani.getBoundingClientRect();
    let bx = r.left + 12;
    let by = r.top  - 44;
    const pad = 8;
    const maxX = innerWidth  - 180;
    const maxY = innerHeight - 48;
    bx = clamp(bx, pad, maxX);
    by = clamp(by, pad, maxY);
    bubble.style.left = bx + 'px';
    bubble.style.top  = by + 'px';
  }

  /* ---------- debug + resize ---------- */
  let debug = false;
  addEventListener('keydown', (e) => {
    if (e.key.toLowerCase() === 'd'){
      debug = !debug;
      const z = computeZones();
      [ditchBox, slopeLeft, slopeRight].forEach(el => el.classList.toggle('debug', debug));
    }
  });
  addEventListener('resize', () => { if (debug) computeZones(); });

  computeZones();
})();
</script>
</body>
</html>
