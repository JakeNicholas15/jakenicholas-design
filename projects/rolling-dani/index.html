<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rolling Dani — DanielleTheWalker.com</title>
  <style>
    html,body{height:100%;margin:0;overflow:hidden;background:#67b0ff;font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;color:#fff}
    canvas{display:block;width:100vw;height:100vh}

    /* HUD text (tiny) */
    .hud{
      position:fixed;top:10px;left:12px;color:#fff;
      font-weight:600;font-size:24px;text-shadow:0 1px 2px rgba(0,0,0,.5);
      user-select:none;pointer-events:none;
    }

    /* Back button – same frosted style as other pages */
    .back-btn{
      position:fixed;bottom:18px;left:18px;width:52px;height:52px;border-radius:50%;
      background:rgba(8,8,8,.4);border:1px solid rgba(255,255,255,.25);
      backdrop-filter:blur(8px) saturate(1.1);
      display:grid;place-items:center;cursor:pointer;color:#fff;font-size:22px;
      box-shadow:0 8px 28px rgba(0,0,0,.35);
      text-decoration:none;
    }
    .back-btn:hover{transform:translateY(-1px)}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="hud" id="hud">SPACE to jump • Hold for higher jump</div>
  <a class="back-btn" href="../../" aria-label="Back to gallery">
    <!-- simple left arrow to match other pages -->
    <span style="font-size:22px;line-height:1;transform:translateX(-1px)">↩︎</span>
  </a>

<script>
(() => {
  // ---------- Canvas setup ----------
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.min(window.devicePixelRatio || 1, 2);
  let W = 0, H = 0;

  function resize() {
    W = canvas.clientWidth;
    H = canvas.clientHeight;
    canvas.width  = W * DPR;
    canvas.height = H * DPR;
    ctx.setTransform(DPR,0,0,DPR,0,0);
  }
  window.addEventListener('resize', resize, {passive:true});
  resize();

  // ---------- Assets ----------
  function loadImage(src){
    return new Promise((res, rej) => {
      const i = new Image();
      i.onload = () => res(i);
      i.onerror = rej;
      i.src = src;
    });
  }
  const ASSETS = {
    ball: loadImage('../../DaniBall.png'),
    ob1:  loadImage('../../obsticle 1 coconut.png'),
    ob2:  loadImage('../../obsticle 2 pickle.png'),
    ob3:  loadImage('../../obsticle 3 tomato.png'),
  };

  // ---------- World constants (tuned) ----------
  const isMobile = /Android|iPhone|iPad|iPod/i.test(navigator.userAgent);
  const BALL_RADIUS = isMobile ? 90 : 130;          // smaller than before
  const OB_SCALE   = isMobile ? 0.42 : 0.5;         // shrink obstacles
  const GRAVITY    = 2600;                          // px/s^2 (snappier airtime)
  const BASE_SPEED = isMobile ? 260 : 300;          // base forward speed
  const SLOPE_GAIN = 900;                           // speed boost from steepness
  const MAX_SPEED  = 1400;
  const AIR_DRAG   = 0.996;

  // Jump: hold to charge up to this many ms
  const HOLD_MAX_MS = 280;                          // shorter hold window
  const JUMP_MIN    = 900;                          // min impulse
  const JUMP_MAX    = 1500;                         // max impulse (quick pop)

  // Camera keeps ground in view – ball slightly above center
  function cameraX() { return player.x - (W * 0.42); }
  function cameraY() { return player.y - (H * 0.62); }

  // ---------- Hill / ground ----------
  // Ground function y = base + waves + long downhill term
  function groundY(x){
    const base = 520;
    const wave = 60 * Math.sin(x / 420) + 36 * Math.sin(x / 1700 + 1.2);
    const long = 0.045 * (x / 2); // increases with distance → steeper downhill
    return base + wave + long;
  }
  function slopeAt(x){
    // numerical derivative (rise/run)
    const e = 1;
    return (groundY(x+e) - groundY(x-e)) / (2*e);
  }

  // ---------- Player ----------
  const player = {
    x: 60, y: groundY(60) - BALL_RADIUS,
    vx: 90, vy: 0, ang: 0, onGround: true, alive: true
  };

  // ---------- Obstacles ----------
  const obstacleImgs = [];
  Promise.all([ASSETS.ob1, ASSETS.ob2, ASSETS.ob3]).then(imgs => {
    obstacleImgs.push(...imgs);
  });

  let obstacles = [];
  function makeObstacle(afterX){
    const img = obstacleImgs[Math.floor(Math.random()*obstacleImgs.length)];
    const w = (img ? img.width : 200) * OB_SCALE;
    const h = (img ? img.height: 200) * OB_SCALE;
    const space = 420 + Math.random()*520;
    const x = afterX + space;
    const gy = groundY(x);
    const y = gy - h + 4; // sink slightly into ground
    return {x, y, w, h, img};
  }
  function ensureObstacles(){
    const minAhead = cameraX() + W + 400;
    if (!obstacles.length){
      obstacles.push(makeObstacle(player.x + 300));
    }
    while (obstacles[obstacles.length-1].x < minAhead){
      obstacles.push(makeObstacle(obstacles[obstacles.length-1].x));
    }
    // cull behind camera
    const cutoff = cameraX() - 600;
    obstacles = obstacles.filter(o => o.x + o.w > cutoff);
  }

  // ---------- Input / jump hold ----------
  let holding = false;
  let holdStart = 0;

  function beginHold(){
    if (!player.alive) { restart(); return; }
    holding = true;
    holdStart = performance.now();
  }
  function endHold(){
    if (!holding) return;
    holding = false;
    const t = Math.min(HOLD_MAX_MS, performance.now() - holdStart);
    const k = t / HOLD_MAX_MS;
    const impulse = JUMP_MIN + (JUMP_MAX - JUMP_MIN) * k;
    if (player.onGround){
      player.vy = -impulse;
      player.onGround = false;
    }
  }

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space') { e.preventDefault(); beginHold(); }
  }, {passive:false});
  window.addEventListener('keyup', (e) => {
    if (e.code === 'Space') { e.preventDefault(); endHold(); }
  }, {passive:false});

  // mobile / mouse tap
  window.addEventListener('pointerdown', (e)=>{ e.preventDefault(); beginHold(); }, {passive:false});
  window.addEventListener('pointerup',   (e)=>{ e.preventDefault(); endHold();   }, {passive:false});

  // ---------- Game loop ----------
  let last = performance.now();
  function tick(now){
    const dt = Math.min(0.033, (now - last)/1000); // clamp dt
    last = now;

    if (player.alive){
      step(dt);
    }
    draw();
    requestAnimationFrame(tick);
  }

  function step(dt){
    // base forward speed + boost from downhill (negative slope = downhill)
    const s = slopeAt(player.x);
    const boost = SLOPE_GAIN * Math.max(0, -s);           // only downhill
    player.vx += ( (BASE_SPEED + boost) - player.vx ) * 0.9 * dt; // smooth accel
    player.vx = Math.min(player.vx, MAX_SPEED);

    // gravity
    player.vy += GRAVITY * dt;
    if (!player.onGround) player.vy *= AIR_DRAG;

    // integrate
    player.x += player.vx * dt;
    player.y += player.vy * dt;

    // ground collision
    const gy = groundY(player.x) - BALL_RADIUS;
    if (player.y > gy){
      player.y = gy;
      player.vy = 0;
      player.onGround = true;
    } else {
      player.onGround = false;
    }

    // rotate based on rolling speed
    player.ang += (player.vx / BALL_RADIUS
