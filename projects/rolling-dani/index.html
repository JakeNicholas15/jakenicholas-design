<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Rolling Dani</title>
<style>
  body { margin: 0; overflow: hidden; background:#87ceeb; }
  canvas { display: block; background:#87ceeb; }
  #back {
    position: absolute; bottom: 20px; left: 20px;
    width: 48px; height: 48px;
    border-radius: 24px; background: rgba(0,0,0,0.4);
    display: flex; align-items: center; justify-content: center;
    color: #fff; font-size: 24px; text-decoration: none;
    user-select: none;
  }
</style>
</head>
<body>
<a id="back" href="../../index.html">←</a>
<canvas id="game"></canvas>
<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let width = window.innerWidth;
  let height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;

  const isMobile = window.matchMedia('(pointer: coarse)').matches || width <= 680;

  let groundY = height * 0.8;
  const gravity = .8;
  const jumpVelocity = 20;
  const BASE_SPEED = 7;               // ← base world scroll speed
    let moveSpeed = BASE_SPEED;         // ← current speed (will ramp)
    const SPEED_RAMP_DURATION = 120;    // ← seconds to reach max (edit here)
    const SPEED_MAX_MULT = 2;           // ← 2x max speed (edit here)
  const SKY_SCROLL_RATIO = 1/3;       // ← sky parallax speed (1/3 of moveSpeed)
  const spawnChance = 0.22;           // ← your current setting
  const spawnGapRatio = 0.3;          // ← your current setting

  // ===== HUD / HINT (start text) =====
  const HINT_TEXT = "Press space to jump";
  const HINT_DURATION_MS = 2500;      // ← show longer (edit here)
  const HINT_FADE_MS = 600;           // ← fade in/out time (edit here)
  const hintStart = performance.now();

  // ===== HIT FLASH + DELAYED RESET =====
  const HIT_FLASH_DURATION = 600;     // red flash total duration (ms)
  const HIT_FLASH_PEAK_ALPHA = 0.7;   // ~70% opacity at peak
  const RESET_DELAY_MS = 2000;        // wait this long after hit before reset
  let gameOver = false;
  let hitTime = 0;                    // timestamp of collision

  // ===== SCORE =====
  let scoreSeconds = 0;               // 1 point per second
  let lastTs = null;                  // for delta-time

  // Ball image
  const ballImg = new Image();
  let ballLoaded = false;
  ballImg.src = '../../DaniBall.png';
  ballImg.onload = () => { ballLoaded = true; };

  // Obstacles
  const obstacleSources = [
    '../../obsticle%201%20coconut.png',
    '../../obsticle%202%20pickle.png',
    '../../obsticle%203%20tomato.png'
  ];
  const obstacleImages = obstacleSources.map(src => {
    const img = new Image();
    img.src = src;
    return img;
  });

  // Grass (seamless) — scrolls at full speed
  const grassImg = new Image();
  let grassLoaded = false;
  let grassWidth = 0;
  grassImg.src = 'DaniRollGrass.png';
  grassImg.onload = () => {
    grassLoaded = true;
    grassWidth = grassImg.width;
  };
  let grassOffset = 0;

  // Sky (parallax) — wraps at 1/3 speed
  const skyImg = new Image();
  let skyLoaded = false;
  let skyOffset = 0;
  skyImg.src = 'DaniRollSky.jpg';
  skyImg.onload = () => { skyLoaded = true; };

  // Ball
  const baseRadius = 50;
  const ball = {
    radius: baseRadius * (isMobile ? 1 : 1.15),
    x: width * 0.15,
    y: groundY - baseRadius,
    vy: 0,
    angle: 0,
    spinFactor: 1,
    update() {
      this.y += this.vy;
      this.vy += gravity;

      if (this.y + this.radius > groundY) {
        this.y = groundY - this.radius;
        this.vy = 0;
        this.spinFactor = 1;
      }
      if (this.y - this.radius < 0) {
        this.y = this.radius;
        this.vy = 0;
        jumpActive = false;
        jumpPressed = false;
        this.spinFactor = 1;
      }
      this.angle += (moveSpeed / (this.radius * 4)) * this.spinFactor;
    },
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.angle);
      if (ballLoaded) {
        ctx.drawImage(ballImg, -this.radius, -this.radius,
                      this.radius*2, this.radius*2);
      } else {
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI*2);
        ctx.fillStyle = '#fff';
        ctx.fill();
      }
      ctx.restore();
    }
  };

  // Obstacles
  const obstacles = [];
  function spawnObstacle() {
const img = obstacleImages[Math.floor(Math.random() * obstacleImages.length)];

// Pick a random height between 100px and 300px
const minHeight = 100;
const maxHeight = 300;
const h = minHeight + Math.random() * (maxHeight - minHeight);

// Keep image aspect ratio
const ratio = (img.naturalWidth || 1) / (img.naturalHeight || 1);
const w = h * ratio;
    obstacles.push({
      x: width + Math.random() * width,
      y: groundY - h,
      width: w,
      height: h,
      img
    });
  }

  // Jump state
  let jumpPressed = false;
  let jumpActive = false;

  window.addEventListener('keydown', e => {
    if (e.code === 'Space') {
      if (!jumpPressed) {
        jumpPressed = true;
        if (!jumpActive && ball.y + ball.radius >= groundY) {
          jumpActive = true;
        }
      }
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', e => {
    if (e.code === 'Space') jumpPressed = false;
  });
  window.addEventListener('touchstart', () => {
    if (!jumpPressed) {
      jumpPressed = true;
      if (!jumpActive && ball.y + ball.radius >= groundY) {
        jumpActive = true;
      }
    }
  });
  window.addEventListener('touchend', () => { jumpPressed = false; });

  // ===== Collision helpers / reset =====
  function circleRectCollides(cx, cy, r, rx, ry, rw, rh) {
    const closestX = Math.max(rx, Math.min(cx, rx + rw));
    const closestY = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) <= r*r;
  }

  function hardResetGame() {
    scoreSeconds = 0;
    obstacles.length = 0;
    grassOffset = 0;
    skyOffset = 0;
    jumpPressed = false;
    jumpActive = false;
    ball.radius = baseRadius * (isMobile ? 1 : 1.15);
    ball.x = width * 0.15;
    ball.y = groundY - ball.radius;
    ball.vy = 0;
    ball.angle = 0;
    ball.spinFactor = 1;
  }

  function triggerGameOver() {
    gameOver = true;
    hitTime = performance.now();
  }

  function update() {
    // If we're in gameOver delay, freeze world and wait for reset
    if (gameOver) {
      // after delay, perform hard reset and resume
      if (performance.now() - hitTime >= RESET_DELAY_MS) {
        hardResetGame();
        gameOver = false;
        lastTs = null; // so score timer restarts cleanly
      }
      return; // skip movement/spawn while flashing & waiting
    }

    // spawn obstacles with spacing
    if (Math.random() < spawnChance) {
      if (obstacles.length === 0 ||
          (width - obstacles[obstacles.length - 1].x) > width * spawnGapRatio) {
        spawnObstacle();
      }
    }
    obstacles.forEach(ob => { ob.x -= moveSpeed; });
    while (obstacles.length && obstacles[0].x + obstacles[0].width < 0) {
      obstacles.shift();
    }

    // parallax sky scroll (wrap by tile width)
    if (skyLoaded) {
      const grassTop = groundY - 50;
      const bottomY = grassTop + 35;
      const skyScale = bottomY / skyImg.height;
      const tileW = skyImg.width * skyScale;

      skyOffset -= moveSpeed * SKY_SCROLL_RATIO;
      if (tileW > 0 && skyOffset <= -tileW) skyOffset += tileW;
    }

    // grass scroll
    if (grassLoaded && grassWidth > 0) {
      grassOffset -= moveSpeed;
      if (grassOffset <= -grassWidth) grassOffset += grassWidth;
    }

    // jumping and spin
    if (jumpActive) {
      if (jumpPressed) {
        ball.vy = -jumpVelocity;
        ball.spinFactor = Math.min(ball.spinFactor + 0.05, 4);
      } else {
        jumpActive = false;
      }
    }

    ball.update();

    // detect collision → trigger delayed reset + flash
    for (let i = 0; i < obstacles.length; i++) {
      const ob = obstacles[i];
      if (circleRectCollides(ball.x, ball.y, ball.radius, ob.x, ob.y, ob.width, ob.height)) {
        triggerGameOver();
        break;
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, width, height);

    // --- SKY (tiled, parallax) ---
    if (skyLoaded) {
      const grassTop = groundY - 50;
      const bottomY = grassTop + 35;
      const skyScale = bottomY / skyImg.height;
      const skyHeight = bottomY;
      const tileW = skyImg.width * skyScale;
      let x = skyOffset;

      while (x > 0) x -= tileW;
      for (; x < width; x += tileW) {
        ctx.drawImage(skyImg, 0, 0, skyImg.width, skyImg.height,
                      x, 0, tileW, skyHeight);
      }
    } else {
      ctx.fillStyle = '#87ceeb';
      ctx.fillRect(0, 0, width, groundY);
    }

    // --- GRASS (tiled, snapped to integers to avoid jitter) ---
    if (grassLoaded && grassWidth > 0) {
      const y = Math.round(groundY - 50);
      const h = grassImg.height;

      let x = Math.floor(grassOffset);
      while (x > 0) x -= grassWidth;
      for (; x < width; x += grassWidth) {
        ctx.drawImage(grassImg, x, y, grassWidth, h);
      }
    } else {
      ctx.fillStyle = '#44aa44';
      ctx.fillRect(0, groundY, width, height - groundY);
    }

    // Obstacles + Ball
    obstacles.forEach(ob => {
      ctx.drawImage(ob.img, ob.x, ob.y, ob.width, ob.height);
    });
    ball.draw();

    // --- SCORE (top-center) ---
    // Edit score SIZE here:
    ctx.font = 'bold 64px Arial, Helvetica, sans-serif';
    // Edit score COLOR here:
    ctx.fillStyle = '#ffffff';
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.lineWidth = 6;
    ctx.strokeStyle = 'rgba(0,0,0,0.45)';
    const scoreText = String(Math.floor(scoreSeconds));
    ctx.strokeText(scoreText, width / 2, 12);
    ctx.fillText(scoreText, width / 2, 12);

    // --- START HINT (fade in/out, centered) ---
    const now = performance.now();
    const t = now - hintStart;
    if (t < HINT_DURATION_MS) {
      let alpha = 1.0;
      if (t < HINT_FADE_MS) {
        alpha = t / HINT_FADE_MS; // fade in
      } else if (t > HINT_DURATION_MS - HINT_FADE_MS) {
        alpha = (HINT_DURATION_MS - t) / HINT_FADE_MS; // fade out
      }
      ctx.save();
      ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
      // Edit hint SIZE here:
      ctx.font = 'bold 44px Arial, Helvetica, sans-serif';
      // Edit hint COLOR here:
      ctx.fillStyle = '#ffffff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.lineWidth = 6;
      ctx.strokeText(HINT_TEXT, width / 2, height / 2);
      ctx.fillText(HINT_TEXT, width / 2, height / 2);
      ctx.restore();
    }

    // --- RED FLASH on hit (fades out) ---
    if (gameOver) {
      const elapsed = now - hitTime;
      if (elapsed < HIT_FLASH_DURATION) {
        // cosine ease-out for a nice falloff
        const k = elapsed / HIT_FLASH_DURATION;
        const ease = Math.cos(k * Math.PI) * 0.5 + 0.5; // 1 -> 0 over duration
        const alpha = HIT_FLASH_PEAK_ALPHA * ease;
        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(HIT_FLASH_PEAK_ALPHA, alpha));
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }
    }
  }

  // main loop with dt for scoring; pauses during gameOver delay
  function loop(ts) {
    if (!gameOver) {
      if (lastTs == null) lastTs = ts;
      const dt = ts - lastTs;
      lastTs = ts;
      scoreSeconds += dt / 1000; // 1 point per second
    } else {
      lastTs = null; // pause score timer while waiting to reset
    }

    update();
    draw();
    requestAnimationFrame(loop);
  }

  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    groundY = height * 0.8;
    ball.radius = baseRadius * (isMobile ? 1 : 1.15);
    ball.x = width * 0.15;
    ball.y = groundY - ball.radius;
  });

  requestAnimationFrame(loop);
</script>
</body>
</html>
