<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Rolling Dani</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #8bd1ee; /* fallback sky color */
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Inter, Arial, sans-serif;
    }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // ---------- Sizing ----------
  let width = canvas.width = window.innerWidth;
  let height = canvas.height = window.innerHeight;

  // Ground baseline (where ball stands)
  const groundY = Math.round(height * 0.82);

  // ---------- Paths & helpers ----------
  const IMG_PATH = './'; // IMPORTANT: index.html lives inside projects/rolling-dani/

  function loadImage(src) {
    const im = new Image();
    im.onload = () => { im.__loaded = true; };
    im.onerror = (e) => console.warn('Image failed:', src, e);
    im.src = src;
    return im;
  }

  // ---------- Assets ----------
  const ballImg  = loadImage(IMG_PATH + 'DaniBall.png');           // player
  const grassImg = loadImage(IMG_PATH + 'DaniRollGrass.png');      // seamless ground strip
  const skyImg   = loadImage(IMG_PATH + 'DaniRollSky.jpg');        // seamless sky

  // Obstacles (use your exact filenames)
  const obstacleImgs = [
    loadImage(IMG_PATH + 'obsticle 1 coconut.png'),
    loadImage(IMG_PATH + 'obsticle 2 pickle.png'),
    loadImage(IMG_PATH + 'obsticle 3 tomato.png'),
  ];

  // ---------- Game params ----------
  const moveSpeed = 7;                 // overall scroll speed (you can tweak)
  const skyParallaxRatio = 1 / 3;      // sky scrolls slower than ground
  const GRASS_LIFT = 50;               // grass drawn 50px above ground line
  const SKY_BELOW_GRASS = 47;          // sky bottom sits 27 + 20 px below grass top

  // Ball physics (tuned previously)
  const ball = {
    x: Math.round(width * 0.1),
    y: groundY - 24,             // corrected after load
    r: 24,                       // corrected after load
    vy: 0,
    onGround: true,
    angle: 0,
    baseSpin: 0.02,              // default spin
    airSpinBoost: 0,
    holdTime: 0
  };

  ballImg.onload = () => {
    ball.r = Math.round((ballImg.width / 2) * 0.575);
    ball.y = groundY - GRASS_LIFT - ball.r;
  };

  // ---------- Scrolling offsets ----------
  let grassOffset = 0; // tile offset for grass
  let skyOffset   = 0; // tile offset for sky

  // ---------- Obstacles ----------
  const obstacles = [];
  let spawnTimer = 0;
  const spawnEvery = 1100; // ms
  const baseWidth = 100;   // used if an obstacle image isn't ready yet

  function spawnObstacle() {
    const img = obstacleImgs[Math.floor(Math.random() * obstacleImgs.length)];
    const isMobile = width < 768;
    // scale range: desktop bigger, mobile smaller
    const minScale = isMobile ? 0.4 : 1.0;
    const maxScale = isMobile ? 1.0 : 2.5;
    const scale = minScale + Math.random() * (maxScale - minScale);

    const naturalW = img.__loaded ? img.naturalWidth : baseWidth;
    const naturalH = img.__loaded ? img.naturalHeight : baseWidth;

    const w = Math.round(naturalW * scale);
    const h = Math.round(naturalH * scale);
    const yBottom = groundY - GRASS_LIFT; // top of the grass
    const y = yBottom - h;                // sit on grass

    obstacles.push({ img, w, h, x: width + 40, y });
  }

  // ---------- Input (jump with hold) ----------
  let jumpHeld = false;
  const JUMP_POWER = -16;
  const GRAVITY = 0.9;
  const MAX_HOLD_MS = 450;

  function startJump() {
    if (!ball.onGround) return;
    ball.onGround = false;
    ball.vy = JUMP_POWER;
    ball.holdTime = 0;
    jumpHeld = true;
  }
  function endJump() { jumpHeld = false; }

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
      e.preventDefault();
      startJump();
    }
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
      e.preventDefault();
      endJump();
    }
  });
  window.addEventListener('touchstart', (e) => { e.preventDefault(); startJump(); }, {passive:false});
  window.addEventListener('touchend',   (e) => { e.preventDefault(); endJump(); },   {passive:false});

  // ---------- Resize ----------
  function onResize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', onResize);
  onResize();

  // ---------- Update / Draw ----------
  let last = performance.now();
  function loop(now) {
    const dt = now - last;
    last = now;

    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt) {
    // Scroll backgrounds
    if (grassImg.__loaded) grassOffset = (grassOffset - moveSpeed) % grassImg.width;
    if (skyImg.__loaded)   skyOffset   = (skyOffset   - moveSpeed * skyParallaxRatio) % skyImg.width;

    // Obstacles move with ground speed
    for (let i = obstacles.length - 1; i >= 0; i--) {
      obstacles[i].x -= moveSpeed;
      if (obstacles[i].x + obstacles[i].w < 0) obstacles.splice(i, 1);
    }

    // Spawn new obstacles
    spawnTimer += dt;
    if (spawnTimer > spawnEvery) {
      spawnTimer = 0;
      spawnObstacle();
    }

    // Ball physics
    if (!ball.onGround) {
      if (jumpHeld && ball.holdTime < MAX_HOLD_MS) {
        ball.holdTime += dt;
        ball.vy += GRAVITY * 0.33; // reduced gravity while holding
        ball.airSpinBoost = 0.02 + 0.0015 * Math.min(ball.holdTime, MAX_HOLD_MS);
      } else {
        ball.vy += GRAVITY;
        ball.airSpinBoost = 0;
      }
      ball.y += ball.vy;

      const floor = groundY - GRASS_LIFT - ball.r;
      if (ball.y >= floor) {
        ball.y = floor;
        ball.vy = 0;
        ball.onGround = true;
        ball.airSpinBoost = 0;
      }
    }

    // Spin (faster in air while holding)
    const spinVel = ball.baseSpin + (ball.onGround ? 0 : ball.airSpinBoost);
    ball.angle += spinVel;
  }

  function draw() {
    ctx.clearRect(0, 0, width, height);

    // --- Draw Sky (tiled, natural size, anchored to grass seam) ---
    const grassTop = groundY - GRASS_LIFT;        // top edge of grass
    const bottomOfSky = grassTop + SKY_BELOW_GRASS;
    const skyTileW = skyImg.__loaded ? skyImg.width : 0;
    const skyTileH = skyImg.__loaded ? skyImg.height : 0;
    const skyY = bottomOfSky - skyTileH;

    if (skyImg.__loaded && skyTileW > 0 && skyTileH > 0) {
      let x = -((skyOffset % skyTileW) + skyTileW) % skyTileW;
      for (; x < width; x += skyTileW) {
        ctx.drawImage(skyImg, x, skyY);
      }
    } else {
      // fallback fill while loading
      ctx.fillStyle = '#8bd1ee';
      ctx.fillRect(0, 0, width, height);
    }

    // --- Draw Grass (tiled strip sitting on ground line) ---
    if (grassImg.__loaded) {
      const h = grassImg.height;
      const y = groundY - GRASS_LIFT;
      let x = -((grassOffset % grassImg.width) + grassImg.width) % grassImg.width;
      for (; x < width; x += grassImg.width) {
        ctx.drawImage(grassImg, x, y, grassImg.width, h);
      }
    } else {
      // fallback rectangle if grass hasn't loaded
      ctx.fillStyle = '#44aa44';
      ctx.fillRect(0, groundY - GRASS_LIFT, width, height - (groundY - GRASS_LIFT));
    }

    // --- Draw obstacles ---
    for (const o of obstacles) {
      if (o.img.__loaded) {
        ctx.drawImage(o.img, o.x, o.y, o.w, o.h);
      } else {
        ctx.fillStyle = 'crimson';
        ctx.fillRect(o.x, o.y, o.w, o.h);
      }
    }

    // --- Draw ball ---
    ctx.save();
    ctx.translate(ball.x, ball.y + ball.r);
    ctx.rotate(ball.angle);
    if (ballImg.__loaded) {
      const d = ball.r * 2;
      ctx.drawImage(ballImg, -ball.r, -ball.r, d, d);
    } else {
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(0, 0, ball.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
