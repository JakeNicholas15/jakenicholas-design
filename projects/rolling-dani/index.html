<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Rolling Dani</title>
<style>
  body { margin: 0; overflow: hidden; background:#87ceeb; }
  canvas { display: block; background:#87ceeb; }
  #back {
    position: absolute; bottom: 20px; left: 20px;
    width: 48px; height: 48px;
    border-radius: 24px; background: rgba(0,0,0,0.4);
    display: flex; align-items: center; justify-content: center;
    color: #fff; font-size: 24px; text-decoration: none;
    user-select: none;
  }
</style>
</head>
<body>
<a id="back" href="../../index.html">←</a>
<canvas id="game"></canvas>
<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  const isMobile = window.matchMedia('(pointer: coarse)').matches || window.innerWidth <= 680;

  let width, height, dpr;
  let groundY;

  // ----- HiDPI-aware sizing (prevents shimmer/jitter) -----
  function resizeCanvas() {
    width = window.innerWidth;
    height = window.innerHeight;
    dpr = window.devicePixelRatio || 1;

    canvas.width  = Math.round(width * dpr);
    canvas.height = Math.round(height * dpr);
    canvas.style.width  = width + 'px';
    canvas.style.height = height + 'px';

    // 1 CSS pixel == 1 unit in drawing ops
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

    groundY = Math.round(height * 0.8);

    // keep ball sizing/position consistent with your logic
    ball.radius = baseRadius * (isMobile ? 1 : 1.15);
    ball.x = Math.round(width * 0.15);
  }

  resizeCanvas();
  window.addEventListener('resize', resizeCanvas);

  const gravity = 1.0;
  const jumpVelocity = 20;
  const moveSpeed = 7;                // ← your requested speed
  const SKY_SCROLL_RATIO = 1/3;       // ← sky parallax speed (1/3 of moveSpeed)
  const spawnChance = 0.022;
  const spawnGapRatio = 0.3;

  // Ball image
  const ballImg = new Image();
  let ballLoaded = false;
  ballImg.src = '../../DaniBall.png';
  ballImg.onload = () => { ballLoaded = true; };

  // Obstacles
  const obstacleSources = [
    '../../obsticle%201%20coconut.png',
    '../../obsticle%202%20pickle.png',
    '../../obsticle%203%20tomato.png'
  ];
  const obstacleImages = obstacleSources.map(src => {
    const img = new Image();
    img.src = src;
    return img;
  });

  // Grass (seamless) — scrolls at full speed
  const grassImg = new Image();
  let grassLoaded = false;
  let grassWidth = 0;
  grassImg.src = 'DaniRollGrass.png';
  grassImg.onload = () => {
    grassLoaded = true;
    grassWidth = grassImg.width;
  };
  let grassOffset = 0;

  // Sky (parallax) — now seamless + wraps at 1/3 speed
  const skyImg = new Image();
  let skyLoaded = false;
  let skyOffset = 0;                  // ← parallax offset
  skyImg.src = 'DaniRollSky.jpg';
  skyImg.onload = () => { skyLoaded = true; };

  // Ball
  const baseRadius = 50;
  const ball = {
    radius: baseRadius * (isMobile ? 1 : 1.15),
    x: Math.round(width * 0.15),
    y: 0, // will be set on first update via groundY
    vy: 0,
    angle: 0,
    spinFactor: 1,
    update() {
      if (this.y === 0) this.y = groundY - this.radius;

      this.y += this.vy;
      this.vy += gravity;

      if (this.y + this.radius > groundY) {
        this.y = groundY - this.radius;
        this.vy = 0;
        this.spinFactor = 1;
      }
      if (this.y - this.radius < 0) {
        this.y = this.radius;
        this.vy = 0;
        jumpActive = false;
        jumpPressed = false;
        this.spinFactor = 1;
      }
      // Spin while rolling
      this.angle += (moveSpeed / (this.radius * 4)) * this.spinFactor;
    },
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.angle);
      if (ballLoaded) {
        ctx.drawImage(ballImg, -this.radius, -this.radius,
                      this.radius*2, this.radius*2);
      } else {
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI*2);
        ctx.fillStyle = '#fff';
        ctx.fill();
      }
      ctx.restore();
    }
  };

  // Obstacles
  const obstacles = [];
  function spawnObstacle() {
    const img = obstacleImages[Math.floor(Math.random() * obstacleImages.length)];
    const scale = isMobile ? 0.5 : 1.5 + Math.random() * 0.5;
    const baseWidth = 80;
    const ratio = (img.naturalWidth || 1) / (img.naturalHeight || 1);
    const w = baseWidth * scale;
    const h = w / ratio;
    obstacles.push({
      x: width + Math.random() * width,
      y: groundY - h,
      width: w,
      height: h,
      img
    });
  }

  // Jump state
  let jumpPressed = false;
  let jumpActive = false;

  window.addEventListener('keydown', e => {
    if (e.code === 'Space') {
      if (!jumpPressed) {
        jumpPressed = true;
        if (!jumpActive && ball.y + ball.radius >= groundY) {
          jumpActive = true;
        }
      }
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', e => {
    if (e.code === 'Space') jumpPressed = false;
  });
  window.addEventListener('touchstart', () => {
    if (!jumpPressed) {
      jumpPressed = true;
      if (!jumpActive && ball.y + ball.radius >= groundY) {
        jumpActive = true;
      }
    }
  });
  window.addEventListener('touchend', () => { jumpPressed = false; });

  function update() {
    // spawn obstacles with spacing
    if (Math.random() < spawnChance) {
      if (obstacles.length === 0 ||
          (width - obstacles[obstacles.length - 1].x) > width * spawnGapRatio) {
        spawnObstacle();
      }
    }
    obstacles.forEach(ob => { ob.x -= moveSpeed; });
    while (obstacles.length && obstacles[0].x + obstacles[0].width < 0) {
      obstacles.shift();
    }

    // parallax sky scroll (wrap by tile width)
    if (skyLoaded) {
      // bottom of the sky is 27px + 20px below the grass top (47px total)
      const grassTop = groundY - 50;
      const bottomY = grassTop + 35;
      const skyScale = bottomY / skyImg.height;              // fill from 0 -> bottomY
      const tileW = skyImg.width * skyScale;

      skyOffset -= moveSpeed * SKY_SCROLL_RATIO;
      if (tileW > 0 && skyOffset <= -tileW) skyOffset += tileW;
    }

    // grass scroll
    if (grassLoaded && grassWidth > 0) {
      grassOffset -= moveSpeed;
      if (grassOffset <= -grassWidth) grassOffset += grassWidth;
    }

    // jumping and spin
    if (jumpActive) {
      if (jumpPressed) {
        ball.vy = -jumpVelocity;
        ball.spinFactor = Math.min(ball.spinFactor + 0.05, 4);
      } else {
        jumpActive = false;
      }
    }

    ball.update();
  }

  function draw() {
    ctx.clearRect(0, 0, width, height);

    // --- SKY (tiled, parallax) ---
    if (skyLoaded) {
      const grassTop = groundY - 50;
      const bottomY = grassTop + 35;
      const skyScale = bottomY / skyImg.height;     // preserves aspect ratio
      const skyHeight = bottomY;                    // draw from 0 to bottomY
      const tileW = skyImg.width * skyScale;
      let x = skyOffset;

      // draw enough tiles to cover canvas width
      while (x > 0) x -= tileW;
      for (; x < width; x += tileW) {
        ctx.drawImage(skyImg, 0, 0, skyImg.width, skyImg.height,
                      x, 0, tileW, skyHeight);
      }
    } else {
      ctx.fillStyle = '#87ceeb';
      ctx.fillRect(0, 0, width, groundY);
    }

    // --- GRASS (tiled, snapped to integers to avoid jitter) ---
    if (grassLoaded && grassWidth > 0) {
      const y = Math.round(groundY - 50);
      const h = grassImg.height;

      let x = Math.floor(grassOffset);   // snap to integer
      while (x > 0) x -= grassWidth;     // draw one tile before 0 to cover wrap
      for (; x < width; x += grassWidth) {
        ctx.drawImage(grassImg, x, y, grassWidth, h);
      }
    } else {
      ctx.fillStyle = '#44aa44';
      ctx.fillRect(0, groundY, width, height - groundY);
    }

    // Obstacles + Ball
    obstacles.forEach(ob => {
      ctx.drawImage(ob.img, ob.x, ob.y, ob.width, ob.height);
    });
    ball.draw();
  }

  function loop() {
    update();
    draw();
    requestAnimationFrame(loop);
  }

  loop();
</script>
</body>
</html>
