<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Rolling Dani</title>
<style>
  body { margin: 0; overflow: hidden; background:#87ceeb; }
  canvas { display: block; background:#87ceeb; }
  #back {
    position: absolute; bottom: 20px; left: 20px;
    width: 48px; height: 48px;
    border-radius: 24px; background: rgba(0,0,0,0.4);
    display: flex; align-items: center; justify-content: center;
    color: #fff; font-size: 24px; text-decoration: none;
    user-select: none;
  }
</style>
</head>
<body>
<a id="back" href="../../index.html">←</a>
<canvas id="game"></canvas>
<script>
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  let width = window.innerWidth;
  let height = window.innerHeight;
  canvas.width = width;
  canvas.height = height;

  const isMobile = window.matchMedia('(pointer: coarse)').matches || width <= 680;

  let groundY = height * 0.8;
  const gravity = 0.8;
  const jumpVelocity = 20;

  const BASE_SPEED = 7;               // base world scroll speed
  let moveSpeed = BASE_SPEED;         // current speed
  const SPEED_RAMP_DURATION = 120;    // seconds to reach max (not applied below)
  const SPEED_MAX_MULT = 5;           // 5x max (not applied below)

  const SKY_SCROLL_RATIO = 1/3;       // sky parallax speed (1/3 of moveSpeed)
  const spawnChance = 0.22;           // your current setting
  const spawnGapRatio = 0.3;          // your current setting

  // ===== HUD / HINT (start text) =====
  const HINT_TEXT = "Press space to jump";
  const HINT_DURATION_MS = 2500;      // show longer (edit here)
  const HINT_FADE_MS = 600;           // fade in/out time (edit here)
  const hintStart = performance.now();

  // ===== HIT FLASH + DELAYED RESET =====
  const HIT_FLASH_DURATION = 600;     // red flash total duration (ms)
  const HIT_FLASH_PEAK_ALPHA = 0.7;   // ~70% opacity at peak
  const RESET_DELAY_MS = 2000;        // wait this long after hit before reset
  let gameOver = false;
  let hitTime = 0;                    // timestamp of collision

  // ===== SCORE =====
  let scoreSeconds = 0;               // 1 point per second
  let lastTs = null;                  // for delta-time

  // Ball image
  const ballImg = new Image();
  let ballLoaded = false;
  ballImg.src = '../../DaniBall.png';
  ballImg.onload = () => { ballLoaded = true; };

  // ===== Obstacles with collider metadata =====
  const obstacleDefs = [
    // Circle colliders (coconut, tomato)
    { src: '../../obsticle%201%20coconut.png', type: 'circle',  radiusFactor: 0.46 },
    { src: '../../obsticle%203%20tomato.png',  type: 'circle',  radiusFactor: 0.48 },

    // Ellipse collider (pickle): skinny horizontally, tall vertically
    {
      src: '../../obsticle%202%20pickle.png',
      type: 'ellipse',
      rxFactor: 0.33,   // narrower horizontally
      ryFactor: 0.80,   // slightly shorter vertically
      padTop: 0.15,     // trim transparent space from top (15%)
      padBottom: 0.05   // trim from bottom (5%)
    }
  ];

  // Load images for each def
  obstacleDefs.forEach(d => {
    const img = new Image();
    img.src = d.src;
    d.img = img;
  });

  // Grass (seamless) — scrolls at full speed
  const grassImg = new Image();
  let grassLoaded = false;
  let grassWidth = 0;
  grassImg.src = 'DaniRollGrass.png';
  grassImg.onload = () => {
    grassLoaded = true;
    grassWidth = grassImg.width;
  };
  let grassOffset = 0;

  // Sky (parallax) — wraps at 1/3 speed
  const skyImg = new Image();
  let skyLoaded = false;
  let skyOffset = 0;
  skyImg.src = 'DaniRollSky.jpg';
  skyImg.onload = () => { skyLoaded = true; };

  // Ball
  const baseRadius = 50;
  const ball = {
    radius: baseRadius * (isMobile ? 1 : 1.15),
    x: width * 0.15,
    y: groundY - baseRadius,
    vy: 0,
    angle: 0,
    spinFactor: 1,
    update() {
      this.y += this.vy;
      this.vy += gravity;

      if (this.y + this.radius > groundY) {
        this.y = groundY - this.radius;
        this.vy = 0;
        this.spinFactor = 1;
      }
      if (this.y - this.radius < 0) {
        this.y = this.radius;
        this.vy = 0;
        jumpActive = false;
        jumpPressed = false;
        this.spinFactor = 1;
      }
      this.angle += (moveSpeed / (this.radius * 4)) * this.spinFactor;
    },
    draw() {
      ctx.save();
      ctx.translate(this.x, this.y);
      ctx.rotate(this.angle);
      if (ballLoaded) {
        ctx.drawImage(ballImg, -this.radius, -this.radius,
                      this.radius*2, this.radius*2);
      } else {
        ctx.beginPath();
        ctx.arc(0, 0, this.radius, 0, Math.PI*2);
        ctx.fillStyle = '#fff';
        ctx.fill();
      }
      ctx.restore();
    }
  };

  // Obstacles list + spawner (height-driven sizing)
  const obstacles = [];
  function spawnObstacle() {
    const def = obstacleDefs[Math.floor(Math.random() * obstacleDefs.length)];
    const img = def.img;

    // Pick a random height between 100px and 350px
    const minHeight = 100;
    const maxHeight = 350;
    const h = minHeight + Math.random() * (maxHeight - minHeight);

    // Keep image aspect ratio
    const ratio = (img.naturalWidth || 1) / (img.naturalHeight || 1);
    const w = h * ratio;

    obstacles.push({
      x: width + Math.random() * width,
      y: groundY - h,
      width: w,
      height: h,
      img,
      collider: def // store collider metadata with the instance
    });
  }

  // Jump state
  let jumpPressed = false;
  let jumpActive = false;

  window.addEventListener('keydown', e => {
    if (e.code === 'Space') {
      if (!jumpPressed) {
        jumpPressed = true;
        if (!jumpActive && ball.y + ball.radius >= groundY) {
          jumpActive = true;
        }
      }
      e.preventDefault();
    }
  });
  window.addEventListener('keyup', e => {
    if (e.code === 'Space') jumpPressed = false;
  });
  window.addEventListener('touchstart', () => {
    if (!jumpPressed) {
      jumpPressed = true;
      if (!jumpActive && ball.y + ball.radius >= groundY) {
        jumpActive = true;
      }
    }
  });
  window.addEventListener('touchend', () => { jumpPressed = false; });

  // ===== Collision helpers =====
  function circleRectCollides(cx, cy, r, rx, ry, rw, rh) {
    const closestX = Math.max(rx, Math.min(cx, rx + rw));
    const closestY = Math.max(ry, Math.min(cy, ry + rh));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) <= r*r;
  }

  function circleCircleCollides(bx, by, br, cx, cy, cr) {
    const dx = bx - cx, dy = by - cy;
    const rr = br + cr;
    return (dx*dx + dy*dy) <= rr*rr;
  }

  // Approximate circle–ellipse by scaling space so ellipse becomes a circle.
  function circleEllipseCollides(bx, by, br, ex, ey, rx, ry) {
    if (rx <= 0 || ry <= 0) return false;
    const dx = (bx - ex) / rx;
    const dy = (by - ey) / ry;
    const rEff = br / Math.min(rx, ry); // conservative ball radius in scaled space
    return (dx*dx + dy*dy) <= (1 + rEff)*(1 + rEff);
  }

  // Reset logic
  function hardResetGame() {
    scoreSeconds = 0;
    obstacles.length = 0;
    grassOffset = 0;
    skyOffset = 0;
    jumpPressed = false;
    jumpActive = false;
    ball.radius = baseRadius * (isMobile ? 1 : 1.15);
    ball.x = width * 0.15;
    ball.y = groundY - ball.radius;
    ball.vy = 0;
    ball.angle = 0;
    ball.spinFactor = 1;
  }

  function triggerGameOver() {
    gameOver = true;
    hitTime = performance.now();
  }

  function update() {
    // Freeze during gameOver delay
    if (gameOver) {
      if (performance.now() - hitTime >= RESET_DELAY_MS) {
        hardResetGame();
        gameOver = false;
        lastTs = null; // restart score timer cleanly
      }
      return;
    }

    // spawn obstacles with spacing
    if (Math.random() < spawnChance) {
      if (obstacles.length === 0 ||
          (width - obstacles[obstacles.length - 1].x) > width * spawnGapRatio) {
        spawnObstacle();
      }
    }
    obstacles.forEach(ob => { ob.x -= moveSpeed; });
    while (obstacles.length && obstacles[0].x + obstacles[0].width < 0) {
      obstacles.shift();
    }

    // parallax sky scroll (wrap by tile width)
    if (skyLoaded) {
      const grassTop = groundY - 50;
      const bottomY = grassTop + 35;
      const skyScale = bottomY / skyImg.height;
      const tileW = skyImg.width * skyScale;

      skyOffset -= moveSpeed * SKY_SCROLL_RATIO;
      if (tileW > 0 && skyOffset <= -tileW) skyOffset += tileW;
    }

    // grass scroll
    if (grassLoaded && grassWidth > 0) {
      grassOffset -= moveSpeed;
      if (grassOffset <= -grassWidth) grassOffset += grassWidth;
    }

    // jumping and spin
    if (jumpActive) {
      if (jumpPressed) {
        ball.vy = -jumpVelocity;
        ball.spinFactor = Math.min(ball.spinFactor + 0.05, 4);
      } else {
        jumpActive = false;
      }
    }

    ball.update();

    // collider-aware collision detection
    for (let i = 0; i < obstacles.length; i++) {
      const ob = obstacles[i];

      let hit = false;
      if (ob.collider && ob.collider.type === 'circle') {
        // Circle collider centered on obstacle center
        const cx = ob.x + ob.width  * 0.5;
        const cy = ob.y + ob.height * 0.5;
        const cr = Math.min(ob.width, ob.height) * (ob.collider.radiusFactor || 0.5);
        hit = circleCircleCollides(ball.x, ball.y, ball.radius, cx, cy, cr);

      } else if (ob.collider && ob.collider.type === 'ellipse') {
        // Ellipse collider centered on a trimmed box (remove transparent top/bottom)
        const padTop = ob.collider.padTop || 0;
        const padBottom = ob.collider.padBottom || 0;
        const trimmedH = ob.height * Math.max(0, 1 - padTop - padBottom);

        const cxTrim = ob.x + ob.width * 0.5;
        const cyTrim = ob.y + ob.height * padTop + trimmedH * 0.5;

        const rx = ob.width  * (ob.collider.rxFactor || 0.5);
        const ry = trimmedH  * (ob.collider.ryFactor || 0.5);

        hit = circleEllipseCollides(ball.x, ball.y, ball.radius, cxTrim, cyTrim, rx, ry);

      } else {
        // Fallback: slightly shrunken rect
        const margin = 10;
        hit = circleRectCollides(
          ball.x, ball.y, ball.radius,
          ob.x + margin, ob.y + margin,
          ob.width - margin*2, ob.height - margin*2
        );
      }

      if (hit) {
        triggerGameOver();
        break;
      }
    }
  }

  function draw() {
    ctx.clearRect(0, 0, width, height);

    // --- SKY (tiled, parallax) ---
    if (skyLoaded) {
      const grassTop = groundY - 50;
      const bottomY = grassTop + 35;
      const skyScale = bottomY / skyImg.height;
      const skyHeight = bottomY;
      const tileW = skyImg.width * skyScale;
      let x = skyOffset;

      while (x > 0) x -= tileW;
      for (; x < width; x += tileW) {
        ctx.drawImage(skyImg, 0, 0, skyImg.width, skyImg.height,
                      x, 0, tileW, skyHeight);
      }
    } else {
      ctx.fillStyle = '#87ceeb';
      ctx.fillRect(0, 0, width, groundY);
    }

    // --- GRASS (tiled, snapped to integers to avoid jitter) ---
    if (grassLoaded && grassWidth > 0) {
      const y = Math.round(groundY - 50);
      const h = grassImg.height;

      let x = Math.floor(grassOffset);
      while (x > 0) x -= grassWidth;
      for (; x < width; x += grassWidth) {
        ctx.drawImage(grassImg, x, y, grassWidth, h);
      }
    } else {
      ctx.fillStyle = '#44aa44';
      ctx.fillRect(0, groundY, width, height - groundY);
    }

    // Obstacles + Ball
    obstacles.forEach(ob => {
      ctx.drawImage(ob.img, ob.x, ob.y, ob.width, ob.height);
    });
    ball.draw();

    // --- SCORE (top-center) ---
    ctx.font = 'bold 64px Arial, Helvetica, sans-serif'; // size
    ctx.fillStyle = '#ffffff';                             // color
    ctx.textAlign = 'center';
    ctx.textBaseline = 'top';
    ctx.lineWidth = 6;
    ctx.strokeStyle = 'rgba(0,0,0,0.45)';
    const scoreText = String(Math.floor(scoreSeconds));
    ctx.strokeText(scoreText, width / 2, 12);
    ctx.fillText(scoreText, width / 2, 12);

    // --- START HINT (fade in/out, centered) ---
    const now = performance.now();
    const t = now - hintStart;
    if (t < HINT_DURATION_MS) {
      let alpha = 1.0;
      if (t < HINT_FADE_MS) {
        alpha = t / HINT_FADE_MS; // fade in
      } else if (t > HINT_DURATION_MS - HINT_FADE_MS) {
        alpha = (HINT_DURATION_MS - t) / HINT_FADE_MS; // fade out
      }
      ctx.save();
      ctx.globalAlpha = Math.max(0, Math.min(1, alpha));
      ctx.font = 'bold 44px Arial, Helvetica, sans-serif'; // hint size
      ctx.fillStyle = '#ffffff';                            // hint color
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.strokeStyle = 'rgba(0,0,0,0.35)';
      ctx.lineWidth = 6;
      ctx.strokeText(HINT_TEXT, width / 2, height / 2);
      ctx.fillText(HINT_TEXT, width / 2, height / 2);
      ctx.restore();
    }

    // --- RED FLASH on hit (fades out) ---
    if (gameOver) {
      const elapsed = now - hitTime;
      if (elapsed < HIT_FLASH_DURATION) {
        const k = elapsed / HIT_FLASH_DURATION;
        const ease = Math.cos(k * Math.PI) * 0.5 + 0.5; // 1 -> 0
        const alpha = HIT_FLASH_PEAK_ALPHA * ease;
        ctx.save();
        ctx.globalAlpha = Math.max(0, Math.min(HIT_FLASH_PEAK_ALPHA, alpha));
        ctx.fillStyle = '#ff0000';
        ctx.fillRect(0, 0, width, height);
        ctx.restore();
      }
    }
  }

  // main loop with dt for scoring; pauses during gameOver delay
  function loop(ts) {
    if (!gameOver) {
      if (lastTs == null) lastTs = ts;
      const dt = ts - lastTs;
      lastTs = ts;
      scoreSeconds += dt / 1000; // 1 point per second
    } else {
      lastTs = null; // pause score timer while waiting to reset
    }

    update();
    draw();
    requestAnimationFrame(loop);
  }

  window.addEventListener('resize', () => {
    width = window.innerWidth;
    height = window.innerHeight;
    canvas.width = width;
    canvas.height = height;
    groundY = height * 0.8;
    ball.radius = baseRadius * (isMobile ? 1 : 1.15);
    ball.x = width * 0.15;
    ball.y = groundY - ball.radius;
  });

  requestAnimationFrame(loop);
</script>
</body>
</html>
