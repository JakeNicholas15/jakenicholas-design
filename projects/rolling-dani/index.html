<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rolling Dani — DanielleTheWalker.com</title>
  <style>
    html,body{height:100%;margin:0;background:#67b0ff;color:#fff;overflow:hidden;
      font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
    canvas{display:block;width:100vw;height:100vh}

    .hud{
      position:fixed;top:10px;left:12px;color:#fff;font-weight:600;font-size:14px;
      text-shadow:0 1px 2px rgba(0,0,0,.5);user-select:none;pointer-events:none;
    }
    .back-btn{
      position:fixed;bottom:18px;left:18px;width:52px;height:52px;border-radius:50%;
      background:rgba(0,0,0,.4);border:1px solid rgba(255,255,255,.3);
      backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);
      display:grid;place-items:center;cursor:pointer;color:#fff;font-size:22px;
      box-shadow:0 6px 24px rgba(0,0,0,.35);text-decoration:none;
    }
    .back-btn:hover{transform:translateY(-1px)}
  </style>
</head>
<body>
  <canvas id="game"></canvas>
  <div class="hud" id="hud">SPACE to jump • Hold for higher jump</div>
  <a class="back-btn" href="../../" aria-label="Back to gallery"><span>←</span></a>

<script>
(() => {
  // ----- Canvas (CSS px, no DPR scaling) -----
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  let W = 0, H = 0;
  function resize(){ W = innerWidth; H = innerHeight; canvas.width = W; canvas.height = H; }
  addEventListener('resize', resize, {passive:true}); resize();

  // ----- Assets -----
  const imgBall = new Image();                 imgBall.src = '../../DaniBall.png';
  const obstacleImgs = [
    '../../obsticle%201%20coconut.png',
    '../../obsticle%202%20pickle.png',
    '../../obsticle%203%20tomato.png'
  ].map(src => { const i = new Image(); i.src = src; return i; });

  // ----- Tunables -----
  const isMobile = /Mobi|Android/i.test(navigator.userAgent);

  const BALL_R   = isMobile ? 50 : 60;         // 100px / 120px diameter
  const G        = 5200;                       // strong gravity (fast airtime)
  const MIN_VJ   = 1250;                       // jump pop
  const HOLD_MS  = 180;                        // hold window
  const EXTRA_MS = 5.2;                        // extra impulse per ms while holding

  const BASE_VX  = 420;                        // faster start
  const MAX_VX   = 2600;                       // cap
  const AIR_DRAG = 0.996;

  // Camera: keep a good band of ground visible
  function camTargetX(){ return ball.x - (W/2 - 320); }
  function camTargetY(){ return ball.y - (H/2 - 140); }
  const cam = {x:0, y:0};

  // ---------- Monotonic downhill ground ----------
  // Slope s(x) <= 0 always. We use two sine components (0..1), scaled and negated.
  // s(x) = -( a + b1 * (1+sin(k1 x))/2 + b2 * (1+sin(k2 x))/2 )
  // groundY(x) is the integral of s(x):
  // y = C - (a + 0.5*b1 + 0.5*b2) * x + (b1/(2*k1)) * cos(k1 x) + (b2/(2*k2)) * cos(k2 x)

  let startedAt = performance.now();
  const rampSecs = 18;                         // time to reach full chaos
  function ease(k){ return k*k*(3-2*k); }      // smoothstep

  function params(){
    const t = (performance.now() - startedAt)/1000;
    const r = ease(Math.min(t/rampSecs, 1));   // 0 → 1 over time

    // Baseline and wave amplitudes (in tan(angle) space).
    // At full ramp: a + b1 + b2 ≈ 1.0 (≈ 45°). Starts near flat.
    const a  = 0.01 + 0.24 * r;                // baseline downhill
    const b1 = 0.00 + 0.48 * r;                // big undulation
    const b2 = 0.00 + 0.27 * r;                // smaller undulation

    // Wavelengths (px): 900px and 450px
    const k1 = 2*Math.PI/900;
    const k2 = 2*Math.PI/450;

    return {a,b1,b2,k1,k2};
  }

  const GROUND_BASE = () => H * 0.78;          // draw ground lower = more visible

  function groundY(x){
    const {a,b1,b2,k1,k2} = params();
    const C = GROUND_BASE();
    return C
      - (a + 0.5*b1 + 0.5*b2) * x
      + (b1/(2*k1)) * Math.cos(k1*x)
      + (b2/(2*k2)) * Math.cos(k2*x);
  }

  function slopeAt(x){
    const {a,b1,b2,k1,k2} = params();
    // analytic derivative (always <= 0)
    return -( a + b1*(1+Math.sin(k1*x))/2 + b2*(1+Math.sin(k2*x))/2 );
  }

  // ---------- Player ----------
  const ball = { x:0, y:0, vx:BASE_VX, vy:0, r:BALL_R, angle:0, grounded:true };
  let gameOver = false;

  // ---------- Obstacles ----------
  const obstacles = [];
  const OB_MIN_GAP = 580, OB_MAX_GAP = 1100;   // a bit more spacing
  const OB_BASE_W  = 48;                       // smaller

  function spawnObstacles(fromX, toX){
    let x = fromX;
    while (x < toX){
      const img = obstacleImgs[(Math.random()*obstacleImgs.length)|0];
      const w = OB_BASE_W + Math.random()*34;
      const h = img.naturalWidth ? w * (img.naturalHeight/img.naturalWidth) : w*1.3;
      const y = groundY(x) - h + 6;
      obstacles.push({x,y,w,h,img});
      x += OB_MIN_GAP + Math.random()*(OB_MAX_GAP-OB_MIN_GAP);
    }
  }

  // ---------- Reset ----------
  function reset(){
    // Start on nearly flat (ramp is ~0), x=0
    ball.x = 0; ball.vx = BASE_VX;
    ball.y = groundY(ball.x) - ball.r; ball.vy = 0;
    ball.angle = 0; ball.grounded = true;

    cam.x = camTargetX(); cam.y = camTargetY();

    obstacles.length = 0;
    spawnObstacles(ball.x + 900, ball.x + 10000); // nothing right at spawn
    startedAt = performance.now();
    gameOver = false;
  }

  // ---------- Input (hold to jump higher) ----------
  let holding = false, holdStart = 0;
  function beginJump(){
    if (!ball.grounded) return;
    holding = true; holdStart = performance.now();
    ball.grounded = false; ball.vy = -MIN_VJ;
  }
  function endJump(){
    if (!holding) return; holding = false;
    const t = Math.min(HOLD_MS, performance.now() - holdStart);
    ball.vy -= EXTRA_MS * t;
  }

  addEventListener('keydown', e=>{
    if (e.code === 'Space'){
      if (!holding) beginJump();
      e.preventDefault();
    }
    if (gameOver && (e.code === 'Space' || e.code === 'Enter')) reset();
  }, {passive:false});
  addEventListener('keyup', e=>{
    if (e.code === 'Space') endJump();
  }, {passive:true});
  addEventListener('pointerdown', ()=>{ if(!holding) beginJump(); }, {passive:true});
  addEventListener('pointerup',   ()=>{ endJump(); },                {passive:true});

  // ---------- Collision ----------
  function hitCircleRect(cx,cy,r, rx,ry,rw,rh){
    const nx = Math.max(rx, Math.min(cx, rx+rw));
    const ny = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx - nx, dy = cy - ny;
    return dx*dx + dy*dy < r*r;
  }

  // ---------- Loop ----------
  let last = performance.now();

  function step(){
    const now = performance.now();
    let dt = (now - last)/1000; last = now;
    if (dt > 0.033) dt = 0.033;

    // slope-based acceleration along the surface (component of gravity)
    const s  = slopeAt(ball.x);
    const ax = G * (s / Math.sqrt(1 + s*s)) * 0.95; // s<=0 → accelerates to right
    const ay = G;

    ball.vx += ax * dt;
    if (ball.vx > MAX_VX) ball.vx = MAX_VX;
    ball.x  += ball.vx * dt;

    if (!ball.grounded) ball.vy *= AIR_DRAG;
    ball.vy += ay * dt;
    ball.y  += ball.vy * dt;

    // ground collide
    const gy = groundY(ball.x);
    if (ball.y > gy - ball.r){
      ball.y = gy - ball.r;
      if (ball.vy > 0) ball.vy = 0;
      ball.grounded = true;
    } else {
      ball.grounded = false;
    }

    // hold boost while airborne
    if (holding && !ball.grounded){
      const held = Math.min(HOLD_MS, performance.now() - holdStart);
      ball.vy -= EXTRA_MS * dt * 1000;
      if (held >= HOLD_MS) holding = false;
    }

    // roll spin
    ball.angle += (ball.vx / ball.r) * dt;

    // camera follow
    cam.x += (camTargetX() - cam.x) * 0.12;
    cam.y += (camTargetY() - cam.y) * 0.12;

    // obstacles upkeep
    const far = ball.x + 9000;
    if (!obstacles.length || obstacles[obstacles.length-1].x < far){
      spawnObstacles(far, far + 10000);
    }
    for (const o of obstacles){
      o.y = groundY(o.x) - o.h + 6; // glue to current ground
      if (hitCircleRect(ball.x, ball.y, ball.r*0.8, o.x, o.y, o.w, o.h)){
        gameOver = true;
      }
    }

    draw();
    requestAnimationFrame(step);
  }

  function draw(){
    ctx.save();
    ctx.translate(-cam.x, -cam.y);

    // sky
    ctx.fillStyle = '#67b0ff';
    ctx.fillRect(cam.x-4000, cam.y-4000, W+8000, H+8000);

    // ground strip (big quad under ground line)
    const x0 = cam.x - 2000, x1 = cam.x + W + 4000;
    const y0 = groundY(x0),   y1 = groundY(x1);

    ctx.fillStyle = '#2ecc40';
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.lineTo(x1, y1 + 4000);
    ctx.lineTo(x0, y0 + 4000);
    ctx.closePath();
    ctx.fill();

    // obstacles
    for (const o of obstacles){
      if (o.img.complete && o.img.naturalWidth){
        ctx.drawImage(o.img, o.x, o.y, o.w, o.h);
      } else {
        ctx.fillStyle = 'rgba(0,0,0,.5)';
        ctx.fillRect(o.x, o.y, o.w, o.h);
      }
    }

    // ball
    ctx.save();
    ctx.translate(ball.x, ball.y);
    ctx.rotate(ball.angle);
    if (imgBall.complete && imgBall.naturalWidth){
      ctx.drawImage(imgBall, -ball.r, -ball.r, ball.r*2, ball.r*2);
    } else {
      ctx.fillStyle = '#333';
      ctx.beginPath(); ctx.arc(0,0,ball.r,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();

    ctx.restore();

    // HUD
    document.getElementById('hud').textContent =
      gameOver ? 'Oof! Press SPACE (or tap) to restart' :
                 'SPACE to jump • Hold for higher jump';
  }

  reset();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
