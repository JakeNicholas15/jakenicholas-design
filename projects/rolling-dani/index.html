<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Rolling Dani</title>
  <style>
    html, body {
      margin: 0;
      padding: 0;
      height: 100%;
      background: #8bd1ee; /* fallback sky color while images load */
      overflow: hidden;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    canvas { display: block; width: 100vw; height: 100vh; }
  </style>
</head>
<body>
<canvas id="game"></canvas>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');

  // ---------- Sizing ----------
  let width = canvas.width = window.innerWidth;
  let height = canvas.height = window.innerHeight;

  // Ground baseline (where ball stands). You can tweak this; grass draws relative to it.
  const groundY = Math.round(height * 0.82);

  // ---------- Assets ----------
  const IMG_PATH = './projects/rolling-dani/';

  // Player ball
  const ballImg = new Image(); ballImg.src = IMG_PATH + 'DaniBall.png';
  let ballLoaded = false; ballImg.onload = () => ballLoaded = true;

  // Grass strip (seamless)
  const grassImg = new Image(); grassImg.src = IMG_PATH + 'DaniRollGrass.png';
  let grassLoaded = false; grassImg.onload = () => grassLoaded = true;

  // Sky (parallax, seamless)
  const skyImg = new Image(); skyImg.src = IMG_PATH + 'DaniRollSky.jpg';
  let skyLoaded = false; skyImg.onload = () => skyLoaded = true;

  // Optional obstacle art (use your images/paths here)
  const obstacleImgs = [
    IMG_PATH + 'Tomato.png',
    IMG_PATH + 'Pickle.png'
  ].map(src => {
    const im = new Image(); im.src = src; return im;
  });

  // ---------- Game params ----------
  const moveSpeed = 7;                 // requested overall scroll speed
  const skyParallaxRatio = 1 / 3;      // sky scrolls slower than ground
  const GRASS_LIFT = 50;               // grass is drawn 50px higher than ground line
  const SKY_BELOW_GRASS = 47;          // sky bottom sits 27+20 px below grass top

  // Ball physics (kept from your working feel)
  const ball = {
    x: Math.round(width * 0.1),
    y: groundY - 24,             // will be corrected once ball image loads
    r: 24,                       // radius (updated when image loads)
    vy: 0,
    onGround: true,
    angle: 0,
    baseSpin: 0.02,              // default spin velocity (radians per frame)
    airSpinBoost: 0,             // extra while holding jump
    holdTime: 0
  };

  ballImg.onload = () => {
    ball.r = Math.round((ballImg.width / 2) * 0.575); // similar to what you had
    ball.y = groundY - GRASS_LIFT - ball.r;           // sit on grass top
  };

  // ---------- Scrolling offsets ----------
  let grassOffset = 0;  // horizontal tile offset for grass
  let skyOffset = 0;    // horizontal tile offset for sky

  // ---------- Obstacles ----------
  const obstacles = [];
  let spawnTimer = 0;
  const spawnEvery = 1100; // ms
  const baseWidth = 100;   // you can tweak this; scale applied below

  function spawnObstacle() {
    const img = obstacleImgs[Math.floor(Math.random() * obstacleImgs.length)];
    // Desktop vs mobile scale range
    const isMobile = width < 768;
    const minScale = isMobile ? 0.4 : 1.0;
    const maxScale = isMobile ? 1.0 : 2.5;
    const scale = minScale + Math.random() * (maxScale - minScale);

    const w = Math.round((img.width || baseWidth) * scale);
    const h = Math.round((img.height || baseWidth) * scale);
    const yBottom = groundY - GRASS_LIFT; // top of the grass
    const y = yBottom - h;                // sit on grass

    obstacles.push({
      img, w, h, x: width + 40, y
    });
  }

  // ---------- Input (jump with hold) ----------
  let jumpHeld = false;
  const JUMP_POWER = -16;   // initial upward velocity
  const GRAVITY = 0.9;      // gravity (will be applied every frame)
  const MAX_HOLD_MS = 450;  // max time to reduce gravity while holding

  function startJump() {
    if (!ball.onGround) return;
    ball.onGround = false;
    ball.vy = JUMP_POWER;
    ball.holdTime = 0;
    jumpHeld = true;
  }
  function endJump() {
    jumpHeld = false;
  }

  window.addEventListener('keydown', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
      e.preventDefault();
      startJump();
    }
  });
  window.addEventListener('keyup', (e) => {
    if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
      e.preventDefault();
      endJump();
    }
  });
  // Touch
  window.addEventListener('touchstart', (e) => { e.preventDefault(); startJump(); }, {passive:false});
  window.addEventListener('touchend',   (e) => { e.preventDefault(); endJump(); },   {passive:false});

  // ---------- Resize ----------
  function onResize() {
    width = canvas.width = window.innerWidth;
    height = canvas.height = window.innerHeight;
  }
  window.addEventListener('resize', onResize);

  // ---------- Update / Draw ----------
  let last = performance.now();
  function loop(now) {
    const dt = now - last;
    last = now;

    update(dt);
    draw();
    requestAnimationFrame(loop);
  }

  function update(dt) {
    // Scroll parallax backgrounds
    grassOffset = (grassOffset - moveSpeed) % (grassImg.width || 1);
    skyOffset   = (skyOffset   - moveSpeed * skyParallaxRatio) % (skyImg.width || 1);

    // Obstacles move with ground speed
    for (let i = obstacles.length - 1; i >= 0; i--) {
      obstacles[i].x -= moveSpeed;
      if (obstacles[i].x + obstacles[i].w < 0) obstacles.splice(i, 1);
    }

    // Spawn
    spawnTimer += dt;
    if (spawnTimer > spawnEvery) {
      spawnTimer = 0;
      spawnObstacle();
    }

    // Ball physics
    if (!ball.onGround) {
      // variable jump height: while holding, ease gravity for a short time
      if (jumpHeld && ball.holdTime < MAX_HOLD_MS) {
        ball.holdTime += dt;
        ball.vy += GRAVITY * 0.33; // milder gravity while holding
        // ramp spin speed in air based on hold duration
        ball.airSpinBoost = 0.02 + 0.0015 * Math.min(ball.holdTime, MAX_HOLD_MS);
      } else {
        ball.vy += GRAVITY;
        ball.airSpinBoost = 0;
      }
      ball.y += ball.vy;

      const floor = groundY - GRASS_LIFT - ball.r;
      if (ball.y >= floor) {
        ball.y = floor;
        ball.vy = 0;
        ball.onGround = true;
        ball.airSpinBoost = 0;
      }
    }

    // Spin while moving; faster if in air & holding
    const spinVel = ball.baseSpin + (ball.onGround ? 0 : ball.airSpinBoost);
    ball.angle += spinVel;
  }

  function draw() {
    ctx.clearRect(0, 0, width, height);

    // --- Draw Sky (tiled, natural size, anchored to grass seam) ---
    const grassTop = groundY - GRASS_LIFT;        // top edge of grass
    const bottomOfSky = grassTop + SKY_BELOW_GRASS;
    const skyTileW = skyImg.width || 1;
    const skyTileH = skyImg.height || 1;
    const skyY = bottomOfSky - skyTileH;

    if (skyLoaded && skyTileW > 1 && skyTileH > 1) {
      let x = -((skyOffset % skyTileW) + skyTileW) % skyTileW;
      for (; x < width; x += skyTileW) {
        ctx.drawImage(skyImg, x, skyY);
      }
    } else {
      // fallback fill until the image is ready
      ctx.fillStyle = '#8bd1ee';
      ctx.fillRect(0, 0, width, height);
    }

    // --- Draw Grass (tiled strip sitting on ground line) ---
    if (grassLoaded) {
      const h = grassImg.height;
      const y = groundY - GRASS_LIFT;
      let x = -((grassOffset % grassImg.width) + grassImg.width) % grassImg.width;
      for (; x < width; x += grassImg.width) {
        ctx.drawImage(grassImg, x, y, grassImg.width, h);
      }
    } else {
      // fallback rectangle if grass hasn't loaded
      ctx.fillStyle = '#44aa44';
      ctx.fillRect(0, groundY - GRASS_LIFT, width, height - (groundY - GRASS_LIFT));
    }

    // --- Draw obstacles ---
    for (const o of obstacles) {
      // draw at natural size (keeps aspect ratio), scaled when spawned
      if (o.img.complete && o.img.naturalWidth) {
        ctx.drawImage(o.img, o.x, o.y, o.w, o.h);
      } else {
        // simple placeholder box
        ctx.fillStyle = 'crimson';
        ctx.fillRect(o.x, o.y, o.w, o.h);
      }
    }

    // --- Draw ball ---
    ctx.save();
    ctx.translate(ball.x, ball.y + ball.r);
    ctx.rotate(ball.angle);
    if (ballLoaded) {
      const d = ball.r * 2;
      ctx.drawImage(ballImg, -ball.r, -ball.r, d, d);
    } else {
      ctx.fillStyle = '#fff';
      ctx.beginPath();
      ctx.arc(0, 0, ball.r, 0, Math.PI * 2);
      ctx.fill();
    }
    ctx.restore();
  }

  // Kick off
  requestAnimationFrame(loop);
})();
</script>
</body>
</html>
