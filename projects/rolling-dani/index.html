<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Rolling Dani — DanielleTheWalker.com</title>
  <style>
    html,body{height:100%;margin:0;background:#67b0ff;color:#fff;overflow:hidden;font:16px/1.4 system-ui,-apple-system,Segoe UI,Roboto,sans-serif;}
    canvas{display:block;width:100vw;height:100vh;}

    /* tiny HUD text */
    .hud{
      position:fixed;top:10px;left:12px;color:#fff;font-weight:600;font-size:14px;
      text-shadow:0 1px 2px rgba(0,0,0,.5);user-select:none;pointer-events:none;
    }

    /* round frosted back button (same vibe as other pages) */
    .back-btn{
      position:fixed;bottom:18px;left:18px;width:52px;height:52px;border-radius:50%;
      background:rgba(0,0,0,.4);border:1px solid rgba(255,255,255,.3);
      backdrop-filter:blur(6px);-webkit-backdrop-filter:blur(6px);
      display:grid;place-items:center;cursor:pointer;color:#fff;font-size:22px;
      box-shadow:0 6px 24px rgba(0,0,0,.35);text-decoration:none;
    }
    .back-btn:hover{transform:translateY(-1px);}
  </style>
</head>
<body>
<canvas id="game"></canvas>
<div class="hud" id="hud">SPACE to jump • Hold for higher jump</div>
<a class="back-btn" href="../../" aria-label="Back to gallery"><span>←</span></a>

<script>
(() => {
  const canvas = document.getElementById('game');
  const ctx = canvas.getContext('2d');
  const DPR = Math.min(window.devicePixelRatio || 1, 2);

  let W = 0, H = 0;
  function resize(){
    W = Math.floor(innerWidth * DPR);
    H = Math.floor(innerHeight * DPR);
    canvas.width = W;
    canvas.height = H;
    canvas.style.width = innerWidth + 'px';
    canvas.style.height = innerHeight + 'px';
  }
  addEventListener('resize', resize, { passive:true });
  resize();

  // ---------- Assets ----------
  const imgBall = new Image();                 imgBall.src = '../../DaniBall.png';
  const obstacleImgs = [
    '../../obsticle%201%20coconut.png',
    '../../obsticle%202%20pickle.png',
    '../../obsticle%203%20tomato.png'
  ].map(src => { const i = new Image(); i.src = src; return i; });

  // ---------- Tunables ----------
  const isMobile = /Mobi|Android/i.test(navigator.userAgent);

  // smaller ball
  const BALL_RADIUS_DESKTOP = 100;             // ~200px diameter
  const BALL_RADIUS_MOBILE  = 70;              // ~140px diameter
  const BALL_RADIUS = (isMobile ? BALL_RADIUS_MOBILE : BALL_RADIUS_DESKTOP) * DPR;

  // slightly more zoomed out on mobile so you can see what's coming
  const CAMERA_SCALE = isMobile ? 0.85 : 1.0;

  // snappier airtime / jump
  const g = 3600;                               // gravity (px/s^2)
  const MAX_HOLD = 200;                         // ms
  const MIN_JUMP_VEL = 1000;                    // initial impulse
  const EXTRA_PER_MS = 3.8;                     // extra while holding

  // slope / speed
  const maxSlope = 0.035;                       // final steepness
  const slopeRampSecs = 14;                     // reaches full steepness sooner
  const baseVX = 340;                           // initial speed

  // ground baseline (in device px)
  let groundY0 = H * 0.55;

  // ---------- World state ----------
  const ball = { x:0, y:0, vx:baseVX, vy:0, r: BALL_RADIUS, angle:0, grounded:true };
  const camera = { x:0, y:0 };
  const obstacles = [];

  // smaller obstacles
  const OB_MIN_GAP = 520;
  const OB_MAX_GAP = 980;
  const OB_BASE_SIZE = 60;                      // used as width baseline (smaller)

  let startedAt = performance.now();
  let gameOver = false;

  // ---------- Ground / slope ----------
  function currentSlope(t){
    const k = Math.min(t / slopeRampSecs, 1);
    const eased = k*k*(3 - 2*k);
    return -(0.004 + (maxSlope - 0.004)*eased);
  }
  function groundHeight(x){
    const t = (performance.now() - startedAt)/1000;
    const m = currentSlope(t);
    // simple linear hill (works well visually with camera)
    return groundY0 + m * x;
  }

  // ---------- Obstacles ----------
  function spawnObstacles(fromX, toX){
    let x = fromX;
    while(x < toX){
      const img = obstacleImgs[(Math.random()*obstacleImgs.length)|0];
      const w = (OB_BASE_SIZE + Math.random()*40) * DPR;   // smaller width
      const h = w * (img.naturalHeight && img.naturalWidth ? img.naturalHeight/img.naturalWidth : 1.4);
      const y = groundHeight(x) - h + 6;                    // slight sink
      obstacles.push({ x, y, w, h, img });
      x += OB_MIN_GAP + Math.random()*(OB_MAX_GAP - OB_MIN_GAP);
    }
  }

  // ---------- Reset ----------
  function reset(){
    ball.x = 0;
    ball.y = groundHeight(ball.x) - ball.r;
    ball.vx = baseVX;
    ball.vy = 0;
    ball.angle = 0;
    ball.grounded = true;

    // put the ball lower on screen so ground is visible
    camera.x = ball.x - (innerWidth*DPR/2 - 280*DPR);
    camera.y = ball.y - (innerHeight*DPR/2 - 160*DPR);

    obstacles.length = 0;
    spawnObstacles(ball.x + 700, ball.x + 8000);
    startedAt = performance.now();
    gameOver = false;
  }

  // ---------- Input (hold jump) ----------
  let jumpKeyDown = false;
  let jumpCharge = 0;

  function beginJump(){
    if(!ball.grounded) return;
    ball.grounded = false;
    jumpCharge = 0;
    ball.vy = -MIN_JUMP_VEL;
  }

  addEventListener('keydown', (e) => {
    if(e.code === 'Space'){
      if(!jumpKeyDown) beginJump();
      jumpKeyDown = true;
      e.preventDefault();
    }
    if(gameOver && (e.code === 'Space' || e.code === 'Enter')) reset();
  }, { passive:false });

  addEventListener('keyup', (e) => {
    if(e.code === 'Space') jumpKeyDown = false;
  }, { passive:true });

  // Touch
  addEventListener('pointerdown', () => { if(!jumpKeyDown) beginJump(); jumpKeyDown = true; }, { passive:true });
  addEventListener('pointerup',   () => { jumpKeyDown = false; }, { passive:true });

  // ---------- Helpers ----------
  function collidesCircleRect(cx, cy, r, rx, ry, rw, rh){
    const closestX = Math.max(rx, Math.min(cx, rx+rw));
    const closestY = Math.max(ry, Math.min(cy, ry+rh));
    const dx = cx - closestX;
    const dy = cy - closestY;
    return (dx*dx + dy*dy) < r*r;
  }

  // ---------- Loop ----------
  let lastTime = performance.now();

  function step(){
    const now = performance.now();
    let dt = (now - lastTime) / 1000;
    lastTime = now;
    if(dt > 0.033) dt = 0.033;

    const tSec = (now - startedAt)/1000;
    const slope = currentSlope(tSec);
    const slopeAngle = Math.atan(slope);

    // snappier jump while holding
    if(!ball.grounded && jumpKeyDown && jumpCharge < MAX_HOLD){
      const add = EXTRA_PER_MS * (dt*1000);
      ball.vy -= add;
      jumpCharge += dt*1000;
    }

    // gravity / motion
    const ax = g * Math.sin(slopeAngle) * 0.95;
    const ay = g;
    ball.vx += ax * dt;
    ball.x  += ball.vx * dt;
    ball.vy += ay * dt;
    ball.y  += ball.vy * dt;

    // ground collision
    const gy = groundHeight(ball.x);
    if(ball.y > gy - ball.r){
      ball.y = gy - ball.r;
      if(ball.vy > 0) ball.vy = 0;
      ball.grounded = true;
    } else {
      ball.grounded = false;
    }

    // roll
    ball.angle += (ball.vx / ball.r) * dt;

    // camera – keep ball lower so ground is visible
    const targetX = ball.x - (innerWidth*DPR/2 - 300*DPR);
    const targetY = ball.y - (innerHeight*DPR/2 - 170*DPR);
    camera.x += (targetX - camera.x) * 0.09;
    camera.y += (targetY - camera.y) * 0.09;

    // obstacles management
    const far = ball.x + 6500;
    if(obstacles.length === 0 || obstacles[obstacles.length-1].x < far){
      spawnObstacles(far, far+8000);
    }
    for(const o of obstacles){
      // adjust to ground (in case slope changed)
      const newY = groundHeight(o.x) - o.h + 6;
      o.y = newY;

      if(collidesCircleRect(ball.x, ball.y, ball.r*0.82, o.x, o.y, o.w, o.h)){
        gameOver = true;
      }
    }

    drawWorld();
    requestAnimationFrame(step);
  }

  function drawWorld(){
    ctx.save();
    ctx.setTransform(CAMERA_SCALE*DPR,0,0,CAMERA_SCALE*DPR,-camera.x*CAMERA_SCALE,-camera.y*CAMERA_SCALE);

    // sky
    ctx.fillStyle = '#67b0ff';
    ctx.fillRect(camera.x-4000,camera.y-4000, innerWidth*DPR/CAMERA_SCALE+8000, innerHeight*DPR/CAMERA_SCALE+8000);

    // ground strip (a long quad along the current slope)
    const tSec = (performance.now() - startedAt)/1000;
    const m = currentSlope(tSec);
    const x0 = camera.x - 2000;
    const x1 = camera.x + innerWidth*DPR/CAMERA_SCALE + 4000;
    const y0 = groundY0 + m * x0;
    const y1 = groundY0 + m * x1;

    ctx.fillStyle = '#2ecc40';
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x1, y1);
    ctx.lineTo(x1, y1 + 6000);
    ctx.lineTo(x0, y0 + 6000);
    ctx.closePath();
    ctx.fill();

    // obstacles
    for(const o of obstacles){
      if(o.img.complete && o.img.naturalWidth){
        ctx.drawImage(o.img, o.x, o.y, o.w, o.h);
      } else {
        ctx.fillStyle = 'rgba(0,0,0,.5)';
        ctx.fillRect(o.x, o.y, o.w, o.h);
      }
    }

    // ball
    ctx.save();
    ctx.translate(ball.x, ball.y);
    ctx.rotate(ball.angle);
    if(imgBall.complete && imgBall.naturalWidth){
      ctx.drawImage(imgBall, -ball.r, -ball.r, ball.r*2, ball.r*2);
    } else {
      ctx.fillStyle = '#333'; ctx.beginPath(); ctx.arc(0,0,ball.r,0,Math.PI*2); ctx.fill();
    }
    ctx.restore();

    ctx.restore();

    // HUD
    const hud = document.getElementById('hud');
    hud.textContent = gameOver ? 'Oof! Press SPACE (or tap) to restart' : 'SPACE to jump • Hold for higher jump';
  }

  reset();
  requestAnimationFrame(step);
})();
</script>
</body>
</html>
